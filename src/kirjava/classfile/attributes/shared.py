#!/usr/bin/env python3

__all__ = (
    "Synthetic", "Signature", "RuntimeVisibleAnnotations", "RuntimeInvisibleAnnotations",
)

"""
Attributes that appear in multiple elements inside a class file.
"""

import logging
from typing import IO, Iterable, List, Tuple, Union

from . import AttributeInfo
from .class_ import Record
from .. import ClassFile
from .._struct import *
from ..constants import ConstantInfo, UTF8
from ..members import FieldInfo, MethodInfo
from ...version import Version

logger = logging.getLogger("kirjava.classfile.attributes.shared")


class Synthetic(AttributeInfo):
    """
    Used to indicate that an element is synthetic (generated by the compiler).
    """

    name_ = "Synthetic"
    since = Version(45, 0)
    locations = (ClassFile, FieldInfo, MethodInfo)

    def __init__(self, parent: Union[ClassFile, FieldInfo, MethodInfo]) -> None:
        super().__init__(parent, Synthetic.name_)

    def __repr__(self) -> str:
        return "<Synthetic() at %x>" % id(self)

    def read(self, class_file: ClassFile, buffer: IO[bytes], fail_fast: bool = True) -> None:
        ...

    def write(self, class_file: ClassFile, buffer: IO[bytes]) -> None:
        ...


class Signature(AttributeInfo):
    """
    Contains extra type information about generics.
    """

    __slots__ = ("signature",)

    name_ = "Signature"
    since = Version(49, 0)
    locations = (ClassFile, FieldInfo, MethodInfo, Record.ComponentInfo)

    def __init__(
            self,
            parent: Union[ClassFile, FieldInfo, MethodInfo, Record.ComponentInfo],
            signature: Union[UTF8, None] = None,
    ) -> None:
        super().__init__(parent, Signature.name_)

        self.signature = signature

    def __repr__(self) -> str:
        return "<Signature(%s) at %x>" % (self.signature, id(self))

    def read(self, class_file: ClassFile, buffer: IO[bytes], fail_fast: bool = True) -> None:
        signature_index, = unpack_H(buffer.read(2))

        # if isinstance(self.parent, MethodInfo):
        #     parse = signature.parse_method_signature
        # elif isinstance(self.parent, ClassFile):
        #     parse = signature.parse_class_signature
        # else:
        #     parse = signature.parse_field_signature

        self.signature = class_file.constant_pool[signature_index]
        # try:
        #     self.type_ = parse(
        #         self.signature,
        #         force_read=self.class_file.context.force_read_signatures,
        #         dont_throw=False,
        #     )
        # except Exception as error:
        #     self.type_ = parse(self.signature, force_read=False, dont_throw=True)

        #     # Definitely too verbose if we're expecting to be decompiling obfuscated files
        #     # logger.warning("Invalid signature %r in class %r: %r" % (
        #     #     self.signature, self.class_file.this_class.name, error.args[0],
        #     # ))
        #     logger.debug("Invalid signature on element %r." % self.parent, exc_info=True)

        # logger.debug("%r signature: %s" % (self.parent, self.signature))

    def write(self, class_file: ClassFile, buffer: IO[bytes]) -> None:
        buffer.write(pack_H(class_file.constant_pool.add(self.signature)))


class Annotations(AttributeInfo):
    """
    Can be present on classes, methods and fields. Represents the runtime visible annotations present on the element.
    """

    __slots__ = ("annotations",)

    since = Version(49, 0)
    locations = (ClassFile, FieldInfo, MethodInfo)

    def __init__(
            self,
            parent: Union[ClassFile, FieldInfo, MethodInfo],
            name: str,
            annotations: Union[Iterable["Annotations.Annotation"], None] = None,
    ) -> None:
        """
        :param annotations: The annotations present in this attribute.
        """

        super().__init__(parent, name)

        self.annotations: List[Annotations.Annotation] = []
        if annotations is not None:
            self.annotations.extend(annotations)

    def __repr__(self) -> str:
        return "<%s(%r) at %x>" % (self.__class__.__name__, self.annotations, id(self))

    def read(self, class_file: ClassFile, buffer: IO[bytes], fail_fast: bool = True) -> None:
        self.annotations.clear()
        annotations_count, = unpack_H(buffer.read(2))
        for index in range(annotations_count):
            self.annotations.append(Annotations.Annotation.read(class_file, buffer, fail_fast))

    def write(self, class_file: ClassFile, buffer: IO[bytes]) -> None:
        buffer.write(pack_H(len(self.annotations)))
        for annotation in self.annotations:
            annotation.write(class_file, buffer)

    class Element:
        """
        An element inside an annotation.
        """

        __slots__ = ("tag", "value")

        @classmethod
        def read(cls, class_file: ClassFile, buffer: IO[bytes], fail_fast: bool) -> "Annotations.Element":
            """
            Reads an annotation element from the buffer.

            :param class_file: The class file that this element belongs to.
            :param buffer: The binary buffer to read from.
            :param fail_fast: Raises an exception if it's clear the element is invalid.
            :return: The read annotation element.
            """

            element = cls.__new__(cls)

            element.tag = buffer.read(1)

            if element.tag in b"BCDFIJSZsc":
                value_index, = unpack_H(buffer.read(2))
                element.value = class_file.constant_pool.get(value_index, do_raise=fail_fast)

            elif element.tag == b"e":
                type_name_index, const_name_index = unpack_HH(buffer.read(4))
                element.value = (
                    class_file.constant_pool.get(type_name_index, do_raise=fail_fast),
                    class_file.constant_pool.get(const_name_index, do_raise=fail_fast),
                )

            elif element.tag == b"@":
                element.value = Annotations.Annotation.read(class_file, buffer, fail_fast)

            elif element.tag == b"[":
                element.value = []

                values_count, = unpack_H(buffer.read(2))
                for index in range(values_count):
                    element.value.append(Annotations.Element.read(class_file, buffer, fail_fast))

            else:
                raise ValueError("Unknown element tag %r." % element.tag)

            return element

        def __init__(
                self,
                tag: bytes,
                value: Union[ConstantInfo, Tuple[UTF8, UTF8], "Annotations.Annotation", List["Annotations.Element"]],
        ) -> None:
            """
            :param tag: The tag that represents the type of value this element holds.
            :param value: The value of this element.
            """

            self.tag = tag
            self.value = value

        def __repr__(self) -> str:
            return "<Element(tag=%r, value=%r) at %x>" % (self.tag, self.value, id(self)) 

        def write(self, class_file: ClassFile, buffer: IO[bytes]) -> None:
            """
            Writes this element to the provided buffer.

            :param class_file: The classfile that this element belongs to.
            :param buffer: The binary buffer to write to.
            """

            buffer.write(self.tag)
            if self.tag in b"BCDFIJSZsc":
                buffer.write(pack_H(class_file.constant_pool.add(self.value)))

            elif self.tag == b"e":
                buffer.write(pack_HH(
                    class_file.constant_pool.add(self.value[0]), class_file.constant_pool.add(self.value[1]),
                ))

            elif self.tag == b"@":
                self.value.write(class_file, buffer)

            elif self.tag == b"[":
                buffer.write(pack_H(len(self.value)))
                for value in self.value:
                    value.write(class_file, buffer)

    class Annotation:
        """
        A Java annotation.
        """

        __slots__ = ("descriptor", "elements")

        @classmethod
        def read(cls, class_file: ClassFile, buffer: IO[bytes], fail_fast: bool) -> "Annotations.Annotation":
            """
            Reads a single annotation from the buffer.

            :param class_file: The class file that annotation belongs to.
            :param buffer: The binary buffer to read from.
            :param fail_fast: Raise an exception if it's clear that the annotation is invalid.
            :return: The read annotation.
            """

            annotation = cls.__new__(cls)

            descriptor_index, elements_count = unpack_HH(buffer.read(4))
            annotation.descriptor = class_file.constant_pool.get(descriptor_index, do_raise=fail_fast)

            annotation.elements = []
            for index in range(elements_count):
                name_index, = unpack_H(buffer.read(2))
                name = class_file.constant_pool.get(name_index, do_raise=fail_fast)

                annotation.elements.append((name, Annotations.Element.read(class_file, buffer, fail_fast)))

            return annotation

        def __init__(
                self, descriptor: UTF8, elements: Union[Iterable[Tuple[UTF8, "Annotations.Element"]], None] = None,
        ) -> None:
            """
            :param descriptor: The type descriptor for this element.
            :param elements: The elements present in this annotation.
            """

            self.descriptor = descriptor
            self.elements: List[Tuple[UTF8, Annotations.Element]] = []

            if elements is not None:
                self.elements.extend(elements)

        def __repr__(self) -> str:
            return "<Annotation(descriptor=%r, elements=%r) at %x>" % (self.descriptor, self.elements, id(self))

        def write(self, class_file: ClassFile, buffer: IO[bytes]) -> None:
            """
            Writes this annotation to the output buffer.

            :param class_file: The classfile that this annotation belongs to.
            :param buffer: The binary buffer to write to.
            """

            buffer.write(pack_HH(class_file.constant_pool.add(self.descriptor), len(self.elements)))
            for name, element in self.elements:
                buffer.write(pack_H(class_file.constant_pool.add(name)))
                element.write(class_file, buffer)


class RuntimeVisibleAnnotations(Annotations):
    """
    Annotations that are visible at runtime.
    """

    name_ = "RuntimeVisibleAnnotations"

    def __init__(
            self,
            parent: Union[ClassFile, FieldInfo, MethodInfo],
            annotations: Union[Iterable["RuntimeVisibleAnnotations.Annotation"], None] = None,
    ) -> None:
        """
        :param annotations: The annotations present in this attribute.
        """

        super().__init__(parent, RuntimeVisibleAnnotations.name_, annotations)


class RuntimeInvisibleAnnotations(Annotations):
    """
    Annotations that exist in the class file but are not visible at runtime.
    """

    name_ = "RuntimeInvisibleAnnotations"

    def __init__(
            self,
            parent: Union[ClassFile, FieldInfo, MethodInfo],
            annotations: Union[Iterable["RuntimeInvisibleAnnotations.Annotation"], None] = None,
    ) -> None:
        """
        :param annotations: The annotations present in this attribute.
        """

        super().__init__(parent, RuntimeInvisibleAnnotations.name_, annotations)
