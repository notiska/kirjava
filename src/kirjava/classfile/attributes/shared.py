#!/usr/bin/env python3

__all__ = (
    "Synthetic", "Signature",
    "Annotations", "RuntimeVisibleAnnotations", "RuntimeInvisibleAnnotations",
)

"""
Attributes that appear in multiple elements inside a class file.
"""

import logging
import typing
from typing import Any, IO, Iterable, Union

from . import AttributeInfo
from .class_ import Record
from ..._struct import *
from ...constants import ConstantInfo, UTF8
from ...version import Version

if typing.TYPE_CHECKING:
    from .. import ClassFile, FieldInfo, MethodInfo

logger = logging.getLogger("kirjava.classfile.attributes.shared")


class Synthetic(AttributeInfo):
    """
    Used to indicate that an element is synthetic (generated by the compiler).
    """

    name_ = "Synthetic"
    since = Version(45, 0)
    locations = ("ClassFile", "FieldInfo", "MethodInfo")

    def __init__(self, parent: Union["ClassFile", "FieldInfo", "MethodInfo"]) -> None:
        super().__init__(parent, Synthetic.name_)

    def __repr__(self) -> str:
        return "<Synthetic() at %x>" % id(self)

    def read(self, class_file: "ClassFile", buffer: IO[bytes], fail_fast: bool = True) -> None:
        ...

    def write(self, class_file: "ClassFile", buffer: IO[bytes]) -> None:
        ...


class Signature(AttributeInfo):
    """
    Contains extra type information about generics.
    """

    __slots__ = ("signature",)

    name_ = "Signature"
    since = Version(49, 0)
    locations = ("ClassFile", "FieldInfo", "MethodInfo", "ComponentInfo")

    def __init__(
            self,
            parent: Union["ClassFile", "FieldInfo", "MethodInfo", Record.ComponentInfo],
            signature: UTF8 | None = None,
    ) -> None:
        super().__init__(parent, Signature.name_)

        self.signature = signature

    def __repr__(self) -> str:
        return "<Signature(%s) at %x>" % (self.signature, id(self))

    def read(self, class_file: "ClassFile", buffer: IO[bytes], fail_fast: bool = True) -> None:
        signature_index, = unpack_H(buffer.read(2))

        # if isinstance(self.parent, MethodInfo):
        #     parse = signature.parse_method_signature
        # elif isinstance(self.parent, ClassFile):
        #     parse = signature.parse_class_signature
        # else:
        #     parse = signature.parse_field_signature

        self.signature = class_file.constant_pool[signature_index]
        # try:
        #     self.type_ = parse(
        #         self.signature,
        #         force_read=self.class_file.context.force_read_signatures,
        #         dont_throw=False,
        #     )
        # except Exception as error:
        #     self.type_ = parse(self.signature, force_read=False, dont_throw=True)

        #     # Definitely too verbose if we're expecting to be decompiling obfuscated files
        #     # logger.warning("Invalid signature %r in class %r: %r" % (
        #     #     self.signature, self.class_file.this_class.name, error.args[0],
        #     # ))
        #     logger.debug("Invalid signature on element %r." % self.parent, exc_info=True)

        # logger.debug("%r signature: %s" % (self.parent, self.signature))

    def write(self, class_file: "ClassFile", buffer: IO[bytes]) -> None:
        buffer.write(pack_H(class_file.constant_pool.add(self.signature)))


class Annotations(AttributeInfo):
    """
    Can be present on classes, methods and fields. Represents the runtime visible annotations present on the element.
    """

    __slots__ = ("annotations",)

    since = Version(49, 0)
    locations = ("ClassFile", "FieldInfo", "MethodInfo")

    def __init__(
            self,
            parent: Union["ClassFile", "FieldInfo", "MethodInfo"],
            name: str,
            annotations: Iterable["Annotations.Annotation"] | None = None,
    ) -> None:
        """
        :param annotations: The annotations present in this attribute.
        """

        super().__init__(parent, name)

        self.annotations: list[Annotations.Annotation] = []
        if annotations is not None:
            self.annotations.extend(annotations)

    def __repr__(self) -> str:
        return "<%s(%r) at %x>" % (type(self).__name__, self.annotations, id(self))

    def __iter__(self) -> Iterable["Annotations.Annotation"]:
        return iter(self.annotations)

    def __getitem__(self, index: int) -> "Annotations.Annotation":
        return self.annotations[index]

    def __setitem__(self, index: int, value: "Annotations.Annotation") -> None:
        self.annotations[index] = value

    def __contains__(self, item: "Annotations.Annotation") -> bool:
        return item in self.annotations

    def __len__(self) -> int:
        return len(self.annotations)

    def read(self, class_file: "ClassFile", buffer: IO[bytes], fail_fast: bool = True) -> None:
        self.annotations.clear()
        annotations_count, = unpack_H(buffer.read(2))
        for index in range(annotations_count):
            self.annotations.append(Annotations.Annotation.read(class_file, buffer, fail_fast))

    def write(self, class_file: "ClassFile", buffer: IO[bytes]) -> None:
        buffer.write(pack_H(len(self.annotations)))
        for annotation in self.annotations:
            annotation.write(class_file, buffer)

    class Element:
        """
        An element inside an annotation.
        """

        __slots__ = ("tag", "value")

        @classmethod
        def read(cls, class_file: "ClassFile", buffer: IO[bytes], fail_fast: bool) -> "Annotations.Element":
            """
            Reads an annotation element from the buffer.

            :param class_file: The class file that this element belongs to.
            :param buffer: The binary buffer to read from.
            :param fail_fast: Raises an exception if it's clear the element is invalid.
            :return: The read annotation element.
            """

            element = cls.__new__(cls)

            element.tag = buffer.read(1)

            if element.tag in b"BCDFIJSZsc":
                value_index, = unpack_H(buffer.read(2))
                element.value = class_file.constant_pool.get(value_index, do_raise=fail_fast)

            elif element.tag == b"e":
                type_name_index, const_name_index = unpack_HH(buffer.read(4))
                element.value = (
                    class_file.constant_pool.get(type_name_index, do_raise=fail_fast),
                    class_file.constant_pool.get(const_name_index, do_raise=fail_fast),
                )

            elif element.tag == b"@":
                element.value = Annotations.Annotation.read(class_file, buffer, fail_fast)

            elif element.tag == b"[":
                element.value = []

                values_count, = unpack_H(buffer.read(2))
                for index in range(values_count):
                    element.value.append(Annotations.Element.read(class_file, buffer, fail_fast))

            else:
                raise ValueError("Unknown element tag %r." % element.tag)

            return element

        def __init__(
                self,
                tag: bytes,
                value: Union[ConstantInfo, tuple[UTF8, UTF8], "Annotations.Annotation", list["Annotations.Element"]],
        ) -> None:
            """
            :param tag: The tag that represents the type of value this element holds.
            :param value: The value of this element.
            """

            self.tag = tag
            self.value = value

        def __repr__(self) -> str:
            return "<Element(tag=%r, value=%r) at %x>" % (self.tag, self.value, id(self)) 

        def __eq__(self, other: Any) -> bool:
            return type(other) is Annotations.Element and other.tag == self.tag and other.value == self.value

        def write(self, class_file: "ClassFile", buffer: IO[bytes]) -> None:
            """
            Writes this element to the provided buffer.

            :param class_file: The classfile that this element belongs to.
            :param buffer: The binary buffer to write to.
            """

            buffer.write(self.tag)
            if self.tag in b"BCDFIJSZsc":
                buffer.write(pack_H(class_file.constant_pool.add(self.value)))

            elif self.tag == b"e":
                buffer.write(pack_HH(
                    class_file.constant_pool.add(self.value[0]), class_file.constant_pool.add(self.value[1]),
                ))

            elif self.tag == b"@":
                self.value.write(class_file, buffer)

            elif self.tag == b"[":
                buffer.write(pack_H(len(self.value)))
                for value in self.value:
                    value.write(class_file, buffer)

    class Annotation:
        """
        A Java annotation.
        """

        __slots__ = ("descriptor", "elements")

        @classmethod
        def read(cls, class_file: "ClassFile", buffer: IO[bytes], fail_fast: bool) -> "Annotations.Annotation":
            """
            Reads a single annotation from the buffer.

            :param class_file: The class file that annotation belongs to.
            :param buffer: The binary buffer to read from.
            :param fail_fast: Raise an exception if it's clear that the annotation is invalid.
            :return: The read annotation.
            """

            annotation = cls.__new__(cls)

            descriptor_index, elements_count = unpack_HH(buffer.read(4))
            annotation.descriptor = class_file.constant_pool.get(descriptor_index, do_raise=fail_fast)

            annotation.elements = []
            for index in range(elements_count):
                name_index, = unpack_H(buffer.read(2))
                name = class_file.constant_pool.get(name_index, do_raise=fail_fast)

                annotation.elements.append((name, Annotations.Element.read(class_file, buffer, fail_fast)))

            return annotation

        def __init__(
                self, descriptor: UTF8, elements: Iterable[tuple[UTF8, "Annotations.Element"]] | None = None,
        ) -> None:
            """
            :param descriptor: The type descriptor for this element.
            :param elements: The elements present in this annotation.
            """

            self.descriptor = descriptor
            self.elements: list[tuple[UTF8, Annotations.Element]] = []

            if elements is not None:
                self.elements.extend(elements)

        def __repr__(self) -> str:
            return "<Annotation(descriptor=%r, elements=%r) at %x>" % (self.descriptor, self.elements, id(self))

        def __iter__(self) -> Iterable[tuple[UTF8, "Annotations.Element"]]:
            return iter(self.elements)

        def __getitem__(self, item: int | str | UTF8) -> tuple[UTF8, "Annotations.Element"]:
            if type(item) is int:
                return self.elements[item]
            if type(item) is str:
                item = UTF8(item)
            for name, element in self.elements:
                if name == item:
                    return name, element

        def __setitem__(self, item: int | str | UTF8, value: "Annotations.Element") -> None:
            if type(item) is int:
                self.elements[item] = value
                return
            if type(item) is str:
                item = UTF8(item)
            for index, (name, element) in enumerate(self.elements):
                if name == item:
                    self.elements[index] = item, value

        def __len__(self) -> int:
            return len(self.elements)

        def write(self, class_file: "ClassFile", buffer: IO[bytes]) -> None:
            """
            Writes this annotation to the output buffer.

            :param class_file: The classfile that this annotation belongs to.
            :param buffer: The binary buffer to write to.
            """

            buffer.write(pack_HH(class_file.constant_pool.add(self.descriptor), len(self.elements)))
            for name, element in self.elements:
                buffer.write(pack_H(class_file.constant_pool.add(name)))
                element.write(class_file, buffer)


class RuntimeVisibleAnnotations(Annotations):
    """
    Annotations that are visible at runtime.
    """

    name_ = "RuntimeVisibleAnnotations"

    def __init__(
            self,
            parent: Union["ClassFile", "FieldInfo", "MethodInfo"],
            annotations: Iterable["RuntimeVisibleAnnotations.Annotation"] | None = None,
    ) -> None:
        """
        :param annotations: The annotations present in this attribute.
        """

        super().__init__(parent, RuntimeVisibleAnnotations.name_, annotations)


class RuntimeInvisibleAnnotations(Annotations):
    """
    Annotations that exist in the class file but are not visible at runtime.
    """

    name_ = "RuntimeInvisibleAnnotations"

    def __init__(
            self,
            parent: Union["ClassFile", "FieldInfo", "MethodInfo"],
            annotations: Iterable["RuntimeInvisibleAnnotations.Annotation"] | None = None,
    ) -> None:
        """
        :param annotations: The annotations present in this attribute.
        """

        super().__init__(parent, RuntimeInvisibleAnnotations.name_, annotations)
