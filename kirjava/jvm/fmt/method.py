#!/usr/bin/env python3

__all__ = (
    "MethodInfo",
    "Code", "StackMapTable",
    "Exceptions", "LineNumberTable", "LocalVariableTable", "LocalVariableTypeTable",
    "RuntimeVisibleParameterAnnotations", "RuntimeInvisibleParameterAnnotations", "AnnotationDefault",
    "MethodParameters",
)

"""
JVM class file method info struct and attributes.
"""

import typing
from os import SEEK_CUR, SEEK_SET
from typing import IO, Iterable

from .annotation import ElementValue, ParameterAnnotations
from .attribute import AttributeInfo
from .constants import *
from .stackmap import StackMapFrame
from .._desc import parse_method_descriptor
from .._struct import *
from ..insns import CodeIOWrapper, Instruction
from ..version import *
from ...meta import Metadata
from ...model.class_.method import Method

if typing.TYPE_CHECKING:
    from .classfile import ClassFile
    from .pool import ConstPool
    from ..verify import Verifier


class MethodInfo:
    """
    A method_info struct.

    Contains the name, descriptor, access flags, and attributes of a method.

    Attributes
    ----------
    ACC_PUBLIC: int
        Access flag denoting that this method is declared `public` and may be
        accessed outside its package.
    ACC_PRIVATE: int
        Access flag denoting that this method is declared `private` and is only
        accessible within this class and other classes belonging to the same nest.
    ACC_PROTECTED: int
        Access flag denoting that this method is declared `protected` and may be
        accessed within subclasses of this class.
    ACC_STATIC: int
        Access flag denoting that this method is declared `static`.
    ACC_FINAL: int
        Access flag denoting that this method is declared `final` and cannot be
        overriden.
    ACC_SYNCHRONIZED: int
        Access flag denoting that this method is declared `synchronized` and any
        invocation is wrapper by a monitor use.
    ACC_BRIDGE: int
        Access flag denoting that this method was generated by the compiler.
    ACC_VARARGS: int
        Access flag denoting that this method accepts arguments in a varargs-like
        format.
    ACC_NATIVE: int
        Access flag denoting that this method is declared `native` and has no
        implementation in Java, but in another language.
    ACC_ABSTRACT: int
        Access flag denoting that this method is declared `abstract` and has no
        implementation.
    ACC_STRICT: int
        Access flag denoting that this method is declared `strictfp` in classes with
        major versions between 46 and 60.
    ACC_SYNTHETIC: int
        Access flag denoting that this method is declared synthetic, meaning it is
        not present in the source.

    is_public: bool
        See `ACC_PUBLIC`.
    is_private: bool
        See `ACC_PRIVATE`.
    is_protected: bool
        See `ACC_PROTECTED`.
    is_static: bool
        See `ACC_STATIC`.
    is_final: bool
        See `ACC_FINAL`.
    is_synchronized: bool
        See `ACC_SYNCHRONIZED`.
    is_bridge: bool
        See `ACC_BRIDGE`.
    is_varargs: bool
        See `ACC_VARARGS`.
    is_native: bool
        See `ACC_NATIVE`.
    is_abstract: bool
        See `ACC_ABSTRACT`.
    is_strict: bool
        See `ACC_STRICT`.
    is_synthetic: bool
        See `ACC_SYNTHETIC`.
    access: int
        A bitmask indicating the access permission and properties of this method.
    name: ConstInfo
        A UTF8 constant, used as the name of this method.
    descriptor: ConstInfo
        A UTF8 constant, used as the descriptor detailing the argument and return
        types of this method.
    attributes: list[AttributeInfo]
        A list of attributes on this method.

    Methods
    -------
    read(stream: IO[bytes], version: Version, pool: ConstPool) -> tuple[MethodInfo, Metadata]
        Reads a method from a binary stream.

    write(self, stream: IO[bytes], version: Version, pool: ConstPool) -> None
        Writes this method to a binary stream.
    verify(self, verifier: Verifier, cf: ClassFile) -> None
        Verifies that this method is valid.
    unwrap(self) -> Method
        Unwraps this method info.
    """

    __slots__ = ("access", "name", "descriptor", "attributes")

    ACC_PUBLIC       = 0x0001
    ACC_PRIVATE      = 0x0002
    ACC_PROTECTED    = 0x0004
    ACC_STATIC       = 0x0008
    ACC_FINAL        = 0x0010
    ACC_SYNCHRONIZED = 0x0020
    ACC_BRIDGE       = 0x0040
    ACC_VARARGS      = 0x0080
    ACC_NATIVE       = 0x0100
    ACC_ABSTRACT     = 0x0400
    ACC_STRICT       = 0x0800
    ACC_SYNTHETIC    = 0x1000

    @classmethod
    def read(cls, stream: IO[bytes], version: "Version", pool: "ConstPool") -> tuple["MethodInfo", Metadata]:
        """
        Reads a method from a binary stream.

        Parameters
        ----------
        stream: IO[bytes]
            The binary stream to read from.
        version: Version
            The class file version.
        pool: ConstantPool
            The class file constant pool.
        """

        meta = Metadata(__name__)
        access, name_index, desc_index, attr_count = unpack_HHHH(stream.read(8))
        attributes = []
        for _ in range(attr_count):
            attr, child_meta = AttributeInfo.read(stream, version, pool, AttributeInfo.LOC_METHOD)
            attributes.append(attr)
            meta.add(child_meta)
        self = cls(access, pool[name_index], pool[desc_index], attributes)
        meta.element = self
        return self, meta

    @property
    def is_public(self) -> bool:
        return bool(self.access & MethodInfo.ACC_PUBLIC)

    @is_public.setter
    def is_public(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_PUBLIC
        else:
            self.access &= ~MethodInfo.ACC_PUBLIC

    @property
    def is_private(self) -> bool:
        return bool(self.access & MethodInfo.ACC_PRIVATE)

    @is_private.setter
    def is_private(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_PRIVATE
        else:
            self.access &= ~MethodInfo.ACC_PRIVATE

    @property
    def is_protected(self) -> bool:
        return bool(self.access & MethodInfo.ACC_PROTECTED)

    @is_protected.setter
    def is_protected(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_PROTECTED
        else:
            self.access &= ~MethodInfo.ACC_PROTECTED

    @property
    def is_static(self) -> bool:
        return bool(self.access & MethodInfo.ACC_STATIC)

    @is_static.setter
    def is_static(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_STATIC
        else:
            self.access &= ~MethodInfo.ACC_STATIC

    @property
    def is_final(self) -> bool:
        return bool(self.access & MethodInfo.ACC_FINAL)

    @is_final.setter
    def is_final(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_FINAL
        else:
            self.access &= ~MethodInfo.ACC_FINAL

    @property
    def is_synchronized(self) -> bool:
        return bool(self.access & MethodInfo.ACC_SYNCHRONIZED)

    @is_synchronized.setter
    def is_synchronized(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_SYNCHRONIZED
        else:
            self.access &= ~MethodInfo.ACC_SYNCHRONIZED

    @property
    def is_bridge(self) -> bool:
        return bool(self.access & MethodInfo.ACC_BRIDGE)

    @is_bridge.setter
    def is_bridge(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_BRIDGE
        else:
            self.access &= ~MethodInfo.ACC_BRIDGE

    @property
    def is_varargs(self) -> bool:
        return bool(self.access & MethodInfo.ACC_VARARGS)

    @is_varargs.setter
    def is_varargs(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_VARARGS
        else:
            self.access &= ~MethodInfo.ACC_VARARGS

    @property
    def is_native(self) -> bool:
        return bool(self.access & MethodInfo.ACC_NATIVE)

    @is_native.setter
    def is_native(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_NATIVE
        else:
            self.access &= ~MethodInfo.ACC_NATIVE

    @property
    def is_abstract(self) -> bool:
        return bool(self.access & MethodInfo.ACC_ABSTRACT)

    @is_abstract.setter
    def is_abstract(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_ABSTRACT
        else:
            self.access &= ~MethodInfo.ACC_ABSTRACT

    @property
    def is_strict(self) -> bool:
        return bool(self.access & MethodInfo.ACC_STRICT)

    @is_strict.setter
    def is_strict(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_STRICT
        else:
            self.access &= ~MethodInfo.ACC_STRICT

    @property
    def is_synthetic(self) -> bool:
        return bool(self.access & MethodInfo.ACC_SYNTHETIC)

    @is_synthetic.setter
    def is_synthetic(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_SYNTHETIC
        else:
            self.access &= ~MethodInfo.ACC_SYNTHETIC

    def __init__(
            self, access: int, name: ConstInfo, descriptor: ConstInfo,
            attributes: Iterable[AttributeInfo] | None = None,
    ) -> None:
        self.access = access
        self.name = name
        self.descriptor = descriptor
        self.attributes: list[AttributeInfo] = []

        if attributes is not None:
            self.attributes.extend(attributes)

    def __repr__(self) -> str:
        return "<MethodInfo(access=0x%04x, name=%s, descriptor=%s)>" % (self.access, self.name, self.descriptor)

    def __str__(self) -> str:
        return "method_info(0x%04x,%s:%s)" % (self.access, self.name, self.descriptor)

    def write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        """
        Writes this method to the binary stream.

        Parameters
        ----------
        stream: IO[bytes]
            The binary stream to write to.
        version: Version
            The class file version.
        pool: ConstPool
            The class file constant pool.

        Raises
        ------
        Exception
            If any writing errors occur.
        """

        stream.write(pack_HHHH(self.access, pool.add(self.name), pool.add(self.descriptor), len(self.attributes)))
        for attribute in self.attributes:
            attribute.write(stream, version, pool)

    def verify(self, verifier: "Verifier", cf: "ClassFile") -> None:
        """
        Verifies that this method is valid.

        Parameters
        ----------
        verifier: Verifier
            The verifier to use and report to.
        cf: ClassFile
            The class file that this method belongs to.
        """

        if not (0 <= self.access <= 65535):
            verifier.fatal(self, "invalid access flags")
        if len(self.attributes) > 65535:
            verifier.fatal(self, "too many attributes")

        if verifier.check_const_types:
            if not isinstance(self.name, UTF8Info):
                verifier.fatal(self, "name is not a UTF8 constant")
            if not isinstance(self.descriptor, UTF8Info):
                verifier.fatal(self, "descriptor is not a UTF8 constant")

        name = b""
        if isinstance(self.name, UTF8Info):
            name = self.name.value

        if verifier.check_access_flags:
            if sum((self.is_public, self.is_private, self.is_protected)) > 1:
                verifier.fatal(self, "conflicting visibility access flags")

            # TODO: Verify <init> is exempt from these rules, as stated in JVMS (unless I misread).
            if name != b"<init>" and cf.is_interface:
                if self.is_protected:
                    verifier.fatal(self, "interface method is protected")
                if self.is_final:
                    verifier.fatal(self, "interface method is final")
                if self.is_synchronized:
                    verifier.fatal(self, "interface method is synchronized")
                if self.is_native:
                    verifier.fatal(self, "interface method is native")

                if cf.version < JAVA_8:
                    if not self.is_public:
                        verifier.fatal(self, "interface method is not public")
                    if not self.is_abstract:
                        verifier.fatal(self, "interface method is not abstract")
                elif not self.is_public and not self.is_private:
                    verifier.fatal(self, "interface method must either be public or private")

            # FIXME: Same check again, I'm not sure all these are correct. Plus may also need to check signature.
            if not name in (b"<init>", b"<clinit>") and self.is_abstract:
                if self.is_private:
                    verifier.fatal(self, "abstract method is private")
                if self.is_static:
                    verifier.fatal(self, "abstract method is static")
                if self.is_final:
                    verifier.fatal(self, "abstract method is final")
                if self.is_synchronized:
                    verifier.fatal(self, "abstract method is synchronized")
                if self.is_native:
                    verifier.fatal(self, "abstract method is native")
                if JAVA_1_2 <= cf.version <= JAVA_16 and self.is_strict:
                    verifier.fatal(self, "abstract method is strictfp")

            if cf.version >= JAVA_7 and name == b"<clinit>" and not self.is_static:
                verifier.fatal(self, "class initialiser is not static")

        for attribute in self.attributes:
            attribute.verify(verifier, cf, AttributeInfo.LOC_METHOD)

    def unwrap(self) -> Method:
        """
        Unwraps this method info.

        Returns
        -------
        Method
            The unwrapped `Method`.
        """

        if not isinstance(self.name, UTF8Info):
            raise ValueError("name is not a UTF8 constant")
        if not isinstance(self.descriptor, UTF8Info):
            raise ValueError("descriptor is not a UTF8 constant")

        return Method(
            self.name.decode(), *parse_method_descriptor(self.descriptor.decode()),
            is_public=self.is_public,
            is_private=self.is_private,
            is_protected=self.is_protected,
            is_static=self.is_static,
            is_final=self.is_final,
            is_synchronized=self.is_synchronized,
            is_bridge=self.is_bridge,
            is_varargs=self.is_varargs,
            is_native=self.is_native,
            is_abstract=self.is_abstract,
            is_strictfp=self.is_strict,
            is_synthetic=self.is_synthetic,
        )


# ---------------------------------------- Attributes ---------------------------------------- #

class Code(AttributeInfo):
    """
    The Code attribute.

    A variable length attribute containing the bytecode and other data required for
    method execution.

    Attributes
    ----------
    max_stack: int
        The maximum operand stack depth reached at any point during execution.
    max_locals: int
        The size of the local variable array.
    base: int
        The base offset of the bytecode.
    instructions: list[Instruction]
        A list of bytecode the decoded instructions.
        It is assumed that the instructions are ordered correctly.
    handlers: list[Code.ExceptionHandler]
        A list of exception handlers ordered by priority.
    attributes: list[AttributeInfo]
        A list of attributes on this code attribute.
    """

    __slots__ = ("max_stack", "max_locals", "base", "instructions", "handlers", "attributes")

    tag = b"Code"
    since = JAVA_1_0
    locations = frozenset({AttributeInfo.LOC_METHOD})

    @classmethod
    def _read(cls, stream: IO[bytes], version: Version, pool: "ConstPool") -> tuple["Code", Metadata]:
        meta = Metadata(__name__)
        # Well known undocumented feature of older Java versions (<45.3) regarding sizes, that we need to account for.
        if version < JAVA_1_1:
            meta.info("read.old", "Read old code size.")
            max_stack, max_locals, size = unpack_BBH(stream.read(4))
        else:
            max_stack, max_locals, size = unpack_HHI(stream.read(8))

        # disassembler = Disassembler()
        # disassembler.disassemble_pure_code(stream, class_file, code_length)

        base = stream.tell()
        instructions = []

        wrapper = CodeIOWrapper(stream, base)
        while wrapper.tell() < size:
            instruction = Instruction.read(wrapper, pool)
            instructions.append(instruction)

        delta = stream.tell() - (base + size)
        if delta:
            meta.error("read.overread", "Code instructions overread by %i byte(s).", delta)
            stream.seek(-delta, SEEK_CUR)

        # TODO: Version checking.

        handler_count, = unpack_H(stream.read(2))
        handlers = []
        for _ in range(handler_count):
            start_pc, end_pc, handler_pc, type_index = unpack_HHHH(stream.read(8))
            handlers.append(cls.ExceptHandler(start_pc, end_pc, handler_pc, pool[type_index] if type_index else None))

        # disassembler.add_exception_table(exception_table)
        # disassembler.disassemble_non_pure_code(stream, class_file)
        # graph = disassembler.make_graph()

        attr_count, = unpack_H(stream.read(2))
        attributes = []
        for _ in range(attr_count):
            attr, child_meta = AttributeInfo.read(stream, version, pool, AttributeInfo.LOC_CODE)
            attributes.append(attr)
            meta.add(child_meta)

        self = cls(max_stack, max_locals, base, instructions, handlers, attributes)
        meta.element = self
        return self, meta

    def __init__(
            self, max_stack: int, max_locals: int, base: int,
            instructions:    Iterable["Instruction"] | None = None,
            handlers: Iterable["Code.ExceptHandler"] | None = None,
            attributes:      Iterable[AttributeInfo] | None = None,
    ) -> None:
        super().__init__()
        self.max_stack = max_stack
        self.max_locals = max_locals
        self.base = base
        self.instructions: list["Instruction"] = []
        self.handlers: list[Code.ExceptHandler] = []
        self.attributes: list[AttributeInfo] = []

        if instructions is not None:
            self.instructions.extend(instructions)
        if handlers is not None:
            self.handlers.extend(handlers)
        if attributes is not None:
            self.attributes.extend(attributes)

    def __repr__(self) -> str:
        return "<Code(max_stack=%i, max_locals=%i, base=%i, instructions=[%s], handlers=%r)>" % (
            self.max_stack, self.max_locals, self.base, ", ".join(map(str, self.instructions)), self.handlers,
        )

    def __str__(self) -> str:
        return "Code(%i,%i,%i,[%s],[%s])" % (
            self.max_stack, self.max_locals, self.base,
            ",".join(map(str, self.instructions)), ",".join(map(str, self.handlers)),
        )

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, Code) and
            self.max_stack == other.max_stack and
            self.max_locals == other.max_locals and
            self.base == other.base and
            self.instructions == other.instructions and
            self.handlers == other.handlers and
            self.attributes == other.attributes
        )

    def _write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        if version < JAVA_1_1:
            stream.write(bytes((self.max_stack, self.max_locals)))
            start = stream.tell()
            stream.write(pack_H(0))
        else:
            stream.write(pack_HH(self.max_stack, self.max_locals))
            start = stream.tell()
            stream.write(pack_I(0))

        base = stream.tell()
        wrapper = CodeIOWrapper(stream, base)

        for instruction in self.instructions:
            # print(instruction.offset + base, instruction)
            instruction.write(wrapper, pool)

        size = wrapper.tell()
        end = stream.tell()
        stream.seek(start, SEEK_SET)
        if version < JAVA_1_1:
            stream.write(pack_H(size))
        else:
            stream.write(pack_I(size))
        stream.seek(end, SEEK_SET)

        stream.write(pack_H(len(self.handlers)))
        for handler in self.handlers:
            stream.write(pack_HHHH(
                handler.start_pc, handler.end_pc, handler.handler_pc,
                pool.add(handler.class_) if handler.class_ is not None else 0,
            ))
        stream.write(pack_H(len(self.attributes)))
        for attribute in self.attributes:
            attribute.write(stream, version, pool)

    def verify(self, verifier: "Verifier", cf: "ClassFile", location: int) -> None:
        super().verify(verifier, cf, location)

        # FIXME: Adjust based on class file version.
        if not (0 <= self.max_stack <= 65535):
            verifier.fatal(self, "invalid max stack size")
        if not (0 <= self.max_locals <= 65535):
            verifier.fatal(self, "invalid max locals size")
        # if len(self.code) > 65535:
        #     verifier.fatal(self, "code too large")

        if len(self.handlers) > 65535:
            verifier.fatal(self, "too many exception handlers")
        for handler in self.handlers:
            # if not (0 <= handler.start_pc < len(self.code)):
            #     verifier.fatal(self, "invalid handler start pc", handler=handler)
            # if not (0 <= handler.end_pc < len(self.code)):
            #     verifier.fatal(self, "invalid handler end pc", handler=handler)
            # if not (0 <= handler.handler_pc < len(self.code)):
            #     verifier.fatal(self, "invalid handler pc", handler=handler)
            if verifier.check_const_types and handler.class_ is not None and not isinstance(handler.class_, ClassInfo):
                verifier.fatal(self, "handler type is not a class constant", handler=handler)

        if len(self.attributes) > 65535:
            verifier.fatal(self, "too many attributes")
        for attribute in self.attributes:
            attribute.verify(verifier, cf, AttributeInfo.LOC_CODE)

    class ExceptHandler:
        """
        An exception handler entry.

        Attributes
        ----------
        start_pc: int
            The starting bytecode offset of this handler's active range.
        end_pc: int
            The ending bytecode offset of this handler's active range.
        handler_pc: int
            The handler bytecode offset.
        class_: ConstInfo | None
            A class constant, used as the type of exception to catch.
            If `None`, all exceptions are caught.
        """

        __slots__ = ("start_pc", "end_pc", "handler_pc", "class_")

        def __init__(self, start_pc: int, end_pc: int, handler_pc: int, class_: ConstInfo | None) -> None:
            self.start_pc = start_pc
            self.end_pc = end_pc
            self.handler_pc = handler_pc
            self.class_ = class_

        def __repr__(self) -> str:
            return "<Code.ExceptHandler(start_pc=%i, end_pc=%i, handler_pc=%i, class_=%s)>" % (
                self.start_pc, self.end_pc, self.handler_pc, self.class_,
            )

        def __str__(self) -> str:
            return "handler(%i-%i:%i,%s)" % (self.start_pc, self.end_pc, self.handler_pc, self.class_)

        def __eq__(self, other: object) -> bool:
            return (
                isinstance(other, Code.ExceptHandler) and
                self.start_pc == other.start_pc and
                self.end_pc == other.end_pc and
                self.handler_pc == other.handler_pc and
                self.class_ == other.class_
            )


class StackMapTable(AttributeInfo):
    """
    The StackMapTable attribute.

    A variable length attribute containing stack map frames used during verification.

    Attributes
    ----------
    frames: list[StackMapFrame]
        A list of stack map frames, see `StackMapFrame`.
    """

    __slots__ = ("frames",)

    tag = b"StackMapTable"
    since = JAVA_6
    locations = frozenset({AttributeInfo.LOC_CODE})

    @classmethod
    def _read(cls, stream: IO[bytes], version: Version, pool: "ConstPool") -> tuple["StackMapTable", None]:
        count, = unpack_H(stream.read(2))
        frames = []
        for _ in range(count):
            frames.append(StackMapFrame.read(stream, pool))
        return cls(frames), None

    def __init__(self, frames: Iterable[StackMapFrame] | None = None) -> None:
        super().__init__()
        self.frames: list[StackMapFrame] = []
        if frames is not None:
            self.frames.extend(frames)

    def __repr__(self) -> str:
        return "<StackMapTable(frames=%r)>" % self.frames

    def __str__(self) -> str:
        return "StackMapTable([%s])" % ",".join(map(str, self.frames))

    def __eq__(self, other: object) -> bool:
        return isinstance(other, StackMapTable) and self.frames == other.frames

    def __getitem__(self, index: int) -> StackMapFrame:
        return self.frames[index]

    def __setitem__(self, index: int, value: StackMapFrame) -> None:
        self.frames[index] = value

    def __delitem__(self, index: int) -> None:
        del self.frames[index]

    def __len__(self) -> int:
        return len(self.frames)

    def _write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        stream.write(pack_H(len(self.frames)))
        for frame in self.frames:
            frame.write(stream, pool)

    def verify(self, verifier: "Verifier", cf: "ClassFile", location: int) -> None:
        super().verify(verifier, cf, location)

        if len(self.frames) > 65535:
            verifier.fatal(self, "too many stack map frames")
        for frame in self.frames:
            frame.verify(verifier)


class Exceptions(AttributeInfo):
    """
    The Exceptions attribute.

    A variable length attribute used to store checked exception information.

    Attributes
    ----------
    exceptions: list[ConstInfo]
        A list of class constants, used to represent checked exceptions that may be
        thrown by this method.
    """

    __slots__ = ("exceptions",)

    tag = b"Exceptions"
    since = JAVA_1_1
    locations = frozenset({AttributeInfo.LOC_METHOD})

    @classmethod
    def _read(cls, stream: IO[bytes], version: Version, pool: "ConstPool") -> tuple["Exceptions", None]:
        count, = unpack_H(stream.read(2))
        return cls([pool[index] for index, in iter_unpack_H(stream.read(count * 2))]), None

    def __init__(self, exceptions: Iterable[ConstInfo] | None = None) -> None:
        super().__init__()
        self.exceptions: list[ConstInfo] = []
        if exceptions is not None:
            self.exceptions.extend(exceptions)

    def __repr__(self) -> str:
        return "<Exceptions(exceptions=[%s])>" % ", ".join(map(str, self.exceptions))

    def __str__(self) -> str:
        return "Exceptions([%s])" % ",".join(map(str, self.exceptions))

    def __eq__(self, other: object) -> bool:
        return isinstance(other, Exceptions) and self.exceptions == other.exceptions

    def __getitem__(self, index: int) -> ConstInfo:
        return self.exceptions[index]

    def __setitem__(self, index: int, value: ConstInfo) -> None:
        self.exceptions[index] = value

    def __delitem__(self, index: int) -> None:
        del self.exceptions[index]

    def __len__(self) -> int:
        return len(self.exceptions)

    def write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        stream.write(pack_HIH(
            pool.add(self.name or UTF8Info(self.tag)),
            2 + len(self.extra) + len(self.exceptions) * 2,
            len(self.exceptions),
        ))
        for exception in self.exceptions:
            stream.write(pack_H(pool.add(exception)))
        stream.write(self.extra)

    def verify(self, verifier: "Verifier", cf: "ClassFile", location: int) -> None:
        super().verify(verifier, cf, location)

        if len(self.exceptions) > 65535:
            verifier.fatal(self, "too many exceptions")
        if verifier.check_const_types:
            for exception in self.exceptions:
                if not isinstance(exception, ClassInfo):
                    # TODO: Fatal? Does JVM crash?
                    verifier.error(self, "exception is not a class constant", exception=exception)


class LineNumberTable(AttributeInfo):
    """
    The LineNumberTable attribute.

    A variable length attribute used to store a mapping of bytecode offsets to
    source code line numbers.

    Attributes
    ----------
    lines: list[LineNumberTable.LineNumber]
        A list of line number entries.
    """

    __slots__ = ("lines",)

    tag = b"LineNumberTable"
    since = JAVA_1_0
    locations = frozenset({AttributeInfo.LOC_CODE})

    @classmethod
    def _read(cls, stream: IO[bytes], version: Version, pool: "ConstPool") -> tuple["LineNumberTable", None]:
        count, = unpack_H(stream.read(2))
        lines = []
        for _ in range(count):
            start_pc, line_number = unpack_HH(stream.read(4))
            lines.append(cls.LineNumber(start_pc, line_number))
        return cls(lines), None

    def __init__(self, lines: Iterable["LineNumberTable.LineNumber"] | None = None) -> None:
        super().__init__()
        self.lines: list[LineNumberTable.LineNumber] = []
        if lines is not None:
            self.lines.extend(lines)

    def __repr__(self) -> str:
        return "<LineNumberTable(lines=%r)>" % self.lines

    def __str__(self) -> str:
        return "LineNumberTable([%s])" % ",".join(map(str, self.lines))

    def __eq__(self, other: object) -> bool:
        return isinstance(other, LineNumberTable) and self.lines == other.lines

    def __getitem__(self, index: int) -> "LineNumberTable.LineNumber":
        return self.lines[index]

    def __setitem__(self, index: int, value: "LineNumberTable.LineNumber") -> None:
        self.lines[index] = value

    def __delitem__(self, index: int) -> None:
        del self.lines[index]

    def __len__(self) -> int:
        return len(self.lines)

    def write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        stream.write(pack_HIH(
            pool.add(self.name or UTF8Info(self.tag)), 2 + len(self.extra) + len(self.lines) * 4, len(self.lines),
        ))
        for line in self.lines:
            stream.write(pack_HH(line.start_pc, line.line))
        stream.write(self.extra)

    def verify(self, verifier: "Verifier", cf: "ClassFile", location: int) -> None:
        super().verify(verifier, cf, location)

        if len(self.lines) > 65535:
            verifier.fatal(self, "too many line numbers")
        for line in self.lines:
            if not (0 <= line.start_pc < 65535):
                verifier.fatal(self, "invalid start pc", line=line)
            if not (0 <= line.line < 65535):
                verifier.fatal(self, "invalid line number", line=line)

    class LineNumber:
        """
        A line number entry.

        Attributes
        ----------
        start_pc: int
            A bytecode offset indicating where the line number starts.
        line: int
            The source code line number.
        """

        __slots__ = ("start_pc", "line")

        def __init__(self, start_pc: int, line: int) -> None:
            self.start_pc = start_pc
            self.line = line

        def __repr__(self) -> str:
            return "<LineNumberTable.LineNumber(start_pc=%i, line=%i)>" % (self.start_pc, self.line)

        def __str__(self) -> str:
            return "line_number(%i,%i)" % (self.start_pc, self.line)

        def __eq__(self, other: object) -> bool:
            return (
                isinstance(other, LineNumberTable.LineNumber) and
                self.start_pc == other.start_pc and
                self.line == other.line
            )


class LocalVariableTable(AttributeInfo):
    """
    The LocalVariableTable attribute.

    A variable length attribute used to store local variable information.

    Attributes
    ----------
    locals: list[LocalVariableTable.LocalVariable]
        A list of local variable information entries.
    """

    __slots__ = ("locals",)

    tag = b"LocalVariableTable"
    # Although maybe true, it was most likely called LocalVariables. Unfortunately the 1.0.2 compiler doesn't emit it,
    # so we can't be sure.
    since = JAVA_1_0
    locations = frozenset({AttributeInfo.LOC_CODE})

    @classmethod
    def _read(cls, stream: IO[bytes], version: Version, pool: "ConstPool") -> tuple["LocalVariableTable", None]:
        count, = unpack_H(stream.read(2))
        locals_ = []
        for _ in range(count):
            start_pc, length, name_index, desc_index, index = unpack_HHHHH(stream.read(10))
            locals_.append(cls.LocalVariable(start_pc, length, pool[name_index], pool[desc_index], index))
        return cls(locals_), None

    def __init__(self, locals_: Iterable["LocalVariableTable.LocalVariable"] | None = None) -> None:
        super().__init__()
        self.locals: list[LocalVariableTable.LocalVariable] = []
        if locals_ is not None:
            self.locals.extend(locals_)

    def __repr__(self) -> str:
        return "<LocalVariableTable(locals=%r)>" % self.locals

    def __str__(self) -> str:
        return "LocalVariableTable([%s])" % ",".join(map(str, self.locals))

    def __eq__(self, other: object) -> bool:
        return isinstance(other, LocalVariableTable) and self.locals == other.locals

    def __getitem__(self, index: int) -> "LocalVariableTable.LocalVariable":
        return self.locals[index]

    def __setitem__(self, index: int, value: "LocalVariableTable.LocalVariable") -> None:
        self.locals[index] = value

    def __delitem__(self, index: int) -> None:
        del self.locals[index]

    def __len__(self) -> int:
        return len(self.locals)

    def write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        stream.write(pack_HIH(
            pool.add(self.name or UTF8Info(self.tag)), 2 + len(self.extra) + len(self.locals) * 10, len(self.locals),
        ))
        for local in self.locals:
            stream.write(pack_HHHHH(
                local.start_pc, local.length, pool.add(local.name), pool.add(local.descriptor), local.index,
            ))
        stream.write(self.extra)

    def verify(self, verifier: "Verifier", cf: "ClassFile", location: int) -> None:
        super().verify(verifier, cf, location)

        if len(self.locals) > 65535:
            verifier.fatal(self, "too many local variables")
        for local in self.locals:
            if not (0 <= local.start_pc < 65535):
                verifier.fatal(self, "invalid local start pc", local=local)
            if not (0 <= local.length < 65535):
                verifier.fatal(self, "invalid local length", local=local)
            if not (0 <= local.index < 65535):
                verifier.fatal(self, "invalid local index", local=local)
            if verifier.check_const_types:
                if not isinstance(local.name, UTF8Info):
                    verifier.error(self, "local name is not a UTF8 constant", local=local)
                if not isinstance(local.descriptor, UTF8Info):
                    verifier.error(self, "local descriptor is not a UTF8 constant", local=local)

    class LocalVariable:
        """
        A local variable table entry.

        Attributes
        ----------
        start_pc: int
            The bytecode offset at which the current local range starts.
        length: int
            The length of the range.
        name: ConstInfo
            A UTF8 constant, used as the name of the local variable.
        descriptor: ConstInfo
            A UTF8 constant, used as the descriptor detailing the type of the local
            variable.
        index: int
            The index of the local variable in the local variable array.
        """

        __slots__ = ("start_pc", "length", "name", "descriptor", "index")

        def __init__(self, start_pc: int, length: int, name: ConstInfo, descriptor: ConstInfo, index: int) -> None:
            self.start_pc = start_pc
            self.length = length
            self.name = name
            self.descriptor = descriptor
            self.index = index

        def __repr__(self) -> str:
            return "<LocalVariableTable.LocalVariable(start_pc=%i, length=%i, name=%s, descriptor=%s, index=%i)>" % (
                self.start_pc, self.length, self.name, self.descriptor, self.index,
            )

        def __str__(self) -> str:
            return "local_variable(%i+%i,%s,%s,%i)" % (
                self.start_pc, self.length, self.name, self.descriptor, self.index,
            )

        def __eq__(self, other: object) -> bool:
            return (
                isinstance(other, LocalVariableTable.LocalVariable) and
                self.start_pc == other.start_pc and
                self.length == other.length and
                self.name == other.name and
                self.descriptor == other.descriptor and
                self.index == other.index
            )


class LocalVariableTypeTable(AttributeInfo):
    """
    The LocalVariableTypeTable attribute.

    A variable length attribute used to store local variable information.
    It differs from `LocalVariableTable` in that generic signature information is
    stored.

    Attributes
    ----------
    locals: list[LocalVariableTypeTable.LocalVariable]
        A list of local variable information entries.
    """

    __slots__ = ("locals",)

    tag = b"LocalVariableTypeTable"
    since = JAVA_5
    locations = frozenset({AttributeInfo.LOC_CODE})

    @classmethod
    def _read(cls, stream: IO[bytes], version: Version, pool: "ConstPool") -> tuple["LocalVariableTypeTable", None]:
        count, = unpack_H(stream.read(2))
        locals_ = []
        for _ in range(count):
            start_pc, length, name_index, sig_index, index = unpack_HHHHH(stream.read(10))
            locals_.append(cls.LocalVariable(start_pc, length, pool[name_index], pool[sig_index], index))
        return cls(locals_), None

    def __init__(self, locals_: Iterable["LocalVariableTypeTable.LocalVariable"] | None = None) -> None:
        super().__init__()
        self.locals: list[LocalVariableTypeTable.LocalVariable] = []
        if locals_ is not None:
            self.locals.extend(locals_)

    def __repr__(self) -> str:
        return "<LocalVariableTypeTable(locals=%r)>" % self.locals

    def __str__(self) -> str:
        return "LocalVariableTypeTable([%s])" % ",".join(map(str, self.locals))

    def __eq__(self, other: object) -> bool:
        return isinstance(other, LocalVariableTypeTable) and self.locals == other.locals

    def __getitem__(self, index: int) -> "LocalVariableTypeTable.LocalVariable":
        return self.locals[index]

    def __setitem__(self, index: int, value: "LocalVariableTypeTable.LocalVariable") -> None:
        self.locals[index] = value

    def __delitem__(self, index: int) -> None:
        del self.locals[index]

    def __len__(self) -> int:
        return len(self.locals)

    def write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        stream.write(pack_HIH(
            pool.add(self.name or UTF8Info(self.tag)), 2 + len(self.extra) + len(self.locals) * 10, len(self.locals),
        ))
        for local in self.locals:
            stream.write(pack_HHHHH(
                local.start_pc, local.length, pool.add(local.name), pool.add(local.signature), local.index,
            ))
        stream.write(self.extra)

    def verify(self, verifier: "Verifier", cf: "ClassFile", location: int) -> None:
        super().verify(verifier, cf, location)

        if len(self.locals) > 65535:
            verifier.fatal(self, "too many local variables")
        for local in self.locals:
            if not (0 <= local.start_pc < 65535):
                verifier.fatal(self, "invalid local start pc", local=local)
            if not (0 <= local.length < 65535):
                verifier.fatal(self, "invalid local length", local=local)
            if not (0 <= local.index < 65535):
                verifier.fatal(self, "invalid local index", local=local)
            if verifier.check_const_types:
                if not isinstance(local.name, UTF8Info):
                    verifier.error(self, "local name is not a UTF8 constant", local=local)
                if not isinstance(local.signature, UTF8Info):
                    verifier.error(self, "local signature is not a UTF8 constant", local=local)

    class LocalVariable:
        """
        A local variable type table entry.

        Attributes
        ----------
        start_pc: int
            The bytecode offset at which the current local range starts.
        length: int
            The length of the range.
        name: ConstInfo
            A UTF8 constant, used as the name of the local variable.
        signature: ConstInfo
            A UTF8 constant, used as the generic signature.
        index: int
            The index of the local variable in the local variable array.
        """

        __slots__ = ("start_pc", "length", "name", "signature", "index")

        def __init__(self, start_pc: int, length: int, name: ConstInfo, signature: ConstInfo, index: int) -> None:
            self.start_pc = start_pc
            self.length = length
            self.name = name
            self.signature = signature
            self.index = index

        def __repr__(self) -> str:
            return "<LocalVariableTypeTable.LocalVariable(start_pc=%i, length=%i, name=%s, signature=%s, index=%i)>" % (
                self.start_pc, self.length, self.name, self.signature, self.index,
            )

        def __str__(self) -> str:
            return "local_variable(%i+%i,%s,%s,%i)" % (
                self.start_pc, self.length, self.name, self.signature, self.index,
            )

        def __eq__(self, other: object) -> bool:
            return (
                isinstance(other, LocalVariableTypeTable.LocalVariable) and
                self.start_pc == other.start_pc and
                self.length == other.length and
                self.name == other.name and
                self.signature == other.signature and
                self.index == other.index
            )


class AnnotationDefault(AttributeInfo):
    """
    An AnnotationDefault attribute primitive.

    A variable length attribute used to store the default value of an element in an
    annotation interface.

    Attributes
    ----------
    default: ElementValue
        The default value of the annotation interface element.
    """

    __slots__ = ("default",)

    tag = b"AnnotationDefault"
    since = JAVA_5
    locations = frozenset({AttributeInfo.LOC_METHOD})

    @classmethod
    def _read(cls, stream: IO[bytes], version: Version, pool: "ConstPool") -> tuple["AnnotationDefault", None]:
        return cls(ElementValue.read(stream, pool)), None

    def __init__(self, default: ElementValue) -> None:
        super().__init__()
        self.default = default

    def __repr__(self) -> str:
        return "<AnnotationDefault(default=%r)>" % self.default

    def __str__(self) -> str:
        return "AnnotationDefault(%s)" % self.default

    def __eq__(self, other: object) -> bool:
        return isinstance(other, AnnotationDefault) and self.default == other.default

    def _write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        self.default.write(stream, pool)


class MethodParameters(AttributeInfo):
    """
    The MethodParameters attribute.

    A variable length attribute used to record information about formal method
    parameters.

    Attributes
    ----------
    params: list[MethodParameters.Parameter]
        A list of formal parameters.
    """

    __slots__ = ("params",)

    tag = b"MethodParameters"
    since = JAVA_8
    locations = frozenset({AttributeInfo.LOC_METHOD})

    @classmethod
    def _read(cls, stream: IO[bytes], version: Version, pool: "ConstPool") -> tuple["MethodParameters", None]:
        count, = stream.read(1)
        params = []
        for _ in range(count):
            name_index, flags = unpack_HH(stream.read(4))
            params.append(cls.Parameter(pool[name_index] if name_index else None, flags))
        return cls(params), None

    def __init__(self, params: Iterable["MethodParameters.Parameter"] | None = None) -> None:
        super().__init__()
        self.params: list[MethodParameters.Parameter] = []
        if params is not None:
            self.params.extend(params)

    def __repr__(self) -> str:
        return "<MethodParameters(params=%r)>" % self.params

    def __str__(self) -> str:
        return "MethodParameters([%s])" % ",".join(map(str, self.params))

    def __eq__(self, other: object) -> bool:
        return isinstance(other, MethodParameters) and self.params == other.params

    def __getitem__(self, index: int) -> "MethodParameters.Parameter":
        return self.params[index]

    def __setitem__(self, index: int, value: "MethodParameters.Parameter") -> None:
        self.params[index] = value

    def __delitem__(self, index: int) -> None:
        del self.params[index]

    def __len__(self) -> int:
        return len(self.params)

    def write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        stream.write(pack_HI(pool.add(UTF8Info(self.tag)), 1 + len(self.extra) + len(self.params) * 4))
        stream.write(bytes((len(self.params),)))
        for param in self.params:
            stream.write(pack_HH(pool.add(param.name) if param.name is not None else 0, param.flags))
        stream.write(self.extra)

    def verify(self, verifier: "Verifier", cf: "ClassFile", location: int) -> None:
        super().verify(verifier, cf, location)

        if len(self.params) > 255:
            verifier.fatal(self, "too many parameters")
        for param in self.params:
            if verifier.check_const_types and param.name is not None and not isinstance(param.name, UTF8Info):
                verifier.error(self, "parameter name is not a UTF8 constant", param=param)
            if not (0 <= param.flags < 65535):
                verifier.fatal(self, "invalid parameter flags", param=param)

    class Parameter:
        """
        A formal parameter entry.

        Attributes
        ----------
        ACC_FINAL: int
            Access flag denoting that this formal parameter is declared `final` in the
            source.
        ACC_SYNTHETIC: int
            Access flag denoting that this formal parameter is not present in the source.
        ACC_MANDATED: int
            Access flag denoting that this formal parameter was implicitly declared in
            the source.

        name: ConstInfo | None
            A UTF8 constant, used as the name of this formal parameter.
            If `None`, then the formal parameter has no name.
        flags: int
            A bitmask indicating the properties of this formal parameter.
        """

        __slots__ = ("name", "flags")

        ACC_FINAL     = 0x0010
        ACC_SYNTHETIC = 0x1000
        ACC_MANDATED  = 0x8000

        @property
        def is_final(self) -> bool:
            return bool(self.flags & MethodParameters.Parameter.ACC_FINAL)

        @is_final.setter
        def is_final(self, value: bool) -> None:
            if value:
                self.flags |= MethodParameters.Parameter.ACC_FINAL
            else:
                self.flags &= ~MethodParameters.Parameter.ACC_FINAL

        @property
        def is_synthetic(self) -> bool:
            return bool(self.flags & MethodParameters.Parameter.ACC_SYNTHETIC)

        @is_synthetic.setter
        def is_synthetic(self, value: bool) -> None:
            if value:
                self.flags |= MethodParameters.Parameter.ACC_SYNTHETIC
            else:
                self.flags &= ~MethodParameters.Parameter.ACC_SYNTHETIC

        @property
        def is_mandated(self) -> bool:
            return bool(self.flags & MethodParameters.Parameter.ACC_MANDATED)

        @is_mandated.setter
        def is_mandated(self, value: bool) -> None:
            if value:
                self.flags |= MethodParameters.Parameter.ACC_MANDATED
            else:
                self.flags &= ~MethodParameters.Parameter.ACC_MANDATED

        def __init__(self, name: ConstInfo | None, flags: int) -> None:
            self.name = name
            self.flags = flags

        def __repr__(self) -> str:
            return "<MethodParameters.Parameter(name=%s, flags=0x%04x)>" % (self.name, self.flags)

        def __str__(self) -> str:
            return "parameter(%s,0x%04x)" % (self.name, self.flags)

        def __eq__(self, other: object) -> bool:
            return (
                isinstance(other, MethodParameters.Parameter) and self.name == other.name and self.flags == other.flags
            )


class RuntimeVisibleParameterAnnotations(AttributeInfo):
    """
    A RuntimeVisibleParameterAnnotations attribute primitive.

    This is a variable length attribute found in methods, storing runtime visible
    annotations declared on the formal parameters of this method.

    Attributes
    ----------
    annotations: list[ParameterAnnotations]
        A list of runtime visible annotations declared on each formal parameter of
        this method.
    """

    __slots__ = ("annotations",)

    tag = b"RuntimeVisibleParameterAnnotations"
    since = JAVA_5
    locations = frozenset({AttributeInfo.LOC_METHOD})

    @classmethod
    def _read(
            cls, stream: IO[bytes], version: Version, pool: "ConstPool",
    ) -> tuple["RuntimeVisibleParameterAnnotations", None]:
        count, = stream.read(1)
        annotations = []
        for _ in range(count):
            annotations.append(ParameterAnnotations.read(stream, pool))
        return cls(annotations), None

    def __init__(self, annotations: list[ParameterAnnotations] | None = None) -> None:
        super().__init__()
        self.annotations = []
        if annotations is not None:
            self.annotations.extend(annotations)

    def __repr__(self) -> str:
        return "<RuntimeVisibleParameterAnnotations(annotations=%r)>" % self.annotations

    def __str__(self) -> str:
        return "RuntimeVisibleParametersAnnotations([%s])" % ",".join(map(str, self.annotations))

    def __eq__(self, other: object) -> bool:
        return isinstance(other, RuntimeVisibleParameterAnnotations) and self.annotations == other.annotations

    def __getitem__(self, index: int) -> ParameterAnnotations:
        return self.annotations[index]

    def __setitem__(self, index: int, value: ParameterAnnotations) -> None:
        self.annotations[index] = value

    def __delitem__(self, index: int) -> None:
        del self.annotations[index]

    def __len__(self) -> int:
        return len(self.annotations)

    def _write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        stream.write(bytes((len(self.annotations),)))
        for annotation in self.annotations:
            annotation.write(stream, pool)


class RuntimeInvisibleParameterAnnotations(AttributeInfo):
    """
    A RuntimeInvisibleParameterAnnotations attribute primitive.

    A variable length attribute used to store runtime-invisible annotations declared
    on the formal parameters of the method containing this attribute.

    Attributes
    ----------
    annotations: list[ParameterAnnotations]
        A list of runtime invisible annotations declared on each formal parameter of
        this method.
    """

    __slots__ = ("annotations",)

    tag = b"RuntimeInvisibleParameterAnnotations"
    since = JAVA_5
    locations = frozenset({AttributeInfo.LOC_METHOD})

    @classmethod
    def _read(
            cls, stream: IO[bytes], version: Version, pool: "ConstPool",
    ) -> tuple["RuntimeInvisibleParameterAnnotations", None]:
        count, = stream.read(1)
        annotations = []
        for _ in range(count):
            annotations.append(ParameterAnnotations.read(stream, pool))
        return cls(annotations), None

    def __init__(self, annotations: list[ParameterAnnotations] | None = None) -> None:
        super().__init__()
        self.annotations = []
        if annotations is not None:
            self.annotations.extend(annotations)

    def __repr__(self) -> str:
        return "<RuntimeInvisibleParameterAnnotations(annotations=%r)>" % self.annotations

    def __str__(self) -> str:
        return "RuntimeInvisibleParametersAnnotations([%s])" % ",".join(map(str, self.annotations))

    def __eq__(self, other: object) -> bool:
        return isinstance(other, RuntimeInvisibleParameterAnnotations) and self.annotations == other.annotations

    def __getitem__(self, index: int) -> ParameterAnnotations:
        return self.annotations[index]

    def __setitem__(self, index: int, value: ParameterAnnotations) -> None:
        self.annotations[index] = value

    def __delitem__(self, index: int) -> None:
        del self.annotations[index]

    def __len__(self) -> int:
        return len(self.annotations)

    def _write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        stream.write(bytes((len(self.annotations),)))
        for annotation in self.annotations:
            annotation.write(stream, pool)
