#!/usr/bin/env python3

from __future__ import annotations

__all__ = (
    "MethodInfo",
    "Code", "StackMapTable",
    "Exceptions", "LineNumberTable", "LocalVariableTable", "LocalVariableTypeTable",
    "RuntimeVisibleParameterAnnotations", "RuntimeInvisibleParameterAnnotations", "AnnotationDefault",
    "MethodParameters",
)

"""
JVM class file method info struct and attributes.
"""

import typing
from os import SEEK_CUR, SEEK_SET
from typing import IO, Iterable, Union

from .annotation import ElementValue, ParameterAnnotations
from .attribute import AttributeInfo
from .constants import *
from .stackmap import StackMapFrame
from .._desc import parse_method_descriptor
from .._struct import *
from ..insns import CodeIOWrapper, Instruction
from ..version import *
from ...meta import Metadata
from ...model.class_.method import Method

if typing.TYPE_CHECKING:
    from .pool import ConstPool


class MethodInfo:
    """
    A method_info struct.

    Contains the name, descriptor, access flags, and attributes of a method.

    Attributes
    ----------
    ACC_PUBLIC: int
        Access flag denoting that this method is declared `public` and may be
        accessed outside its package.
    ACC_PRIVATE: int
        Access flag denoting that this method is declared `private` and is only
        accessible within this class and other classes belonging to the same nest.
    ACC_PROTECTED: int
        Access flag denoting that this method is declared `protected` and may be
        accessed within subclasses of this class.
    ACC_STATIC: int
        Access flag denoting that this method is declared `static`.
    ACC_FINAL: int
        Access flag denoting that this method is declared `final` and cannot be
        overriden.
    ACC_SYNCHRONIZED: int
        Access flag denoting that this method is declared `synchronized` and any
        invocation is wrapper by a monitor use.
    ACC_BRIDGE: int
        Access flag denoting that this method was generated by the compiler.
    ACC_VARARGS: int
        Access flag denoting that this method accepts arguments in a varargs-like
        format.
    ACC_NATIVE: int
        Access flag denoting that this method is declared `native` and has no
        implementation in Java, but in another language.
    ACC_ABSTRACT: int
        Access flag denoting that this method is declared `abstract` and has no
        implementation.
    ACC_STRICT: int
        Access flag denoting that this method is declared `strictfp` in classes with
        major versions between 46 and 60.
    ACC_SYNTHETIC: int
        Access flag denoting that this method is declared synthetic, meaning it is
        not present in the source.

    is_public: bool
        See `ACC_PUBLIC`.
    is_private: bool
        See `ACC_PRIVATE`.
    is_protected: bool
        See `ACC_PROTECTED`.
    is_static: bool
        See `ACC_STATIC`.
    is_final: bool
        See `ACC_FINAL`.
    is_synchronized: bool
        See `ACC_SYNCHRONIZED`.
    is_bridge: bool
        See `ACC_BRIDGE`.
    is_varargs: bool
        See `ACC_VARARGS`.
    is_native: bool
        See `ACC_NATIVE`.
    is_abstract: bool
        See `ACC_ABSTRACT`.
    is_strict: bool
        See `ACC_STRICT`.
    is_synthetic: bool
        See `ACC_SYNTHETIC`.
    access: int
        A bitmask indicating the access permission and properties of this method.
    name: ConstInfo
        A UTF8 constant, used as the name of this method.
    descriptor: ConstInfo
        A UTF8 constant, used as the descriptor detailing the argument and return
        types of this method.
    attributes: list[AttributeInfo]
        A list of attributes on this method.

    Methods
    -------
    read(stream: IO[bytes], version: Version, pool: ConstPool) -> tuple[MethodInfo, Metadata]
        Reads a method from a binary stream.

    write(self, stream: IO[bytes], version: Version, pool: ConstPool) -> None
        Writes this method to a binary stream.
    unwrap(self) -> Method
        Unwraps this method info.
    """

    __slots__ = ("access", "name", "descriptor", "attributes")

    ACC_PUBLIC       = 0x0001
    ACC_PRIVATE      = 0x0002
    ACC_PROTECTED    = 0x0004
    ACC_STATIC       = 0x0008
    ACC_FINAL        = 0x0010
    ACC_SYNCHRONIZED = 0x0020
    ACC_BRIDGE       = 0x0040
    ACC_VARARGS      = 0x0080
    ACC_NATIVE       = 0x0100
    ACC_ABSTRACT     = 0x0400
    ACC_STRICT       = 0x0800
    ACC_SYNTHETIC    = 0x1000

    @classmethod
    def read(cls, stream: IO[bytes], version: "Version", pool: "ConstPool") -> tuple["MethodInfo", Metadata]:
        """
        Reads a method from a binary stream.

        Parameters
        ----------
        stream: IO[bytes]
            The binary stream to read from.
        version: Version
            The class file version.
        pool: ConstantPool
            The class file constant pool.
        """

        meta = Metadata(__name__)
        access, name_index, desc_index, attr_count = unpack_HHHH(stream.read(8))
        attributes = []
        for _ in range(attr_count):
            attr, child_meta = AttributeInfo.read(stream, version, pool, AttributeInfo.LOC_METHOD)
            attributes.append(attr)
            meta.add(child_meta)
        self = cls(access, pool[name_index], pool[desc_index], attributes)
        meta.element = self
        return self, meta

    @property
    def is_public(self) -> bool:
        return bool(self.access & MethodInfo.ACC_PUBLIC)

    @is_public.setter
    def is_public(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_PUBLIC
        else:
            self.access &= ~MethodInfo.ACC_PUBLIC

    @property
    def is_private(self) -> bool:
        return bool(self.access & MethodInfo.ACC_PRIVATE)

    @is_private.setter
    def is_private(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_PRIVATE
        else:
            self.access &= ~MethodInfo.ACC_PRIVATE

    @property
    def is_protected(self) -> bool:
        return bool(self.access & MethodInfo.ACC_PROTECTED)

    @is_protected.setter
    def is_protected(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_PROTECTED
        else:
            self.access &= ~MethodInfo.ACC_PROTECTED

    @property
    def is_static(self) -> bool:
        return bool(self.access & MethodInfo.ACC_STATIC)

    @is_static.setter
    def is_static(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_STATIC
        else:
            self.access &= ~MethodInfo.ACC_STATIC

    @property
    def is_final(self) -> bool:
        return bool(self.access & MethodInfo.ACC_FINAL)

    @is_final.setter
    def is_final(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_FINAL
        else:
            self.access &= ~MethodInfo.ACC_FINAL

    @property
    def is_synchronized(self) -> bool:
        return bool(self.access & MethodInfo.ACC_SYNCHRONIZED)

    @is_synchronized.setter
    def is_synchronized(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_SYNCHRONIZED
        else:
            self.access &= ~MethodInfo.ACC_SYNCHRONIZED

    @property
    def is_bridge(self) -> bool:
        return bool(self.access & MethodInfo.ACC_BRIDGE)

    @is_bridge.setter
    def is_bridge(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_BRIDGE
        else:
            self.access &= ~MethodInfo.ACC_BRIDGE

    @property
    def is_varargs(self) -> bool:
        return bool(self.access & MethodInfo.ACC_VARARGS)

    @is_varargs.setter
    def is_varargs(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_VARARGS
        else:
            self.access &= ~MethodInfo.ACC_VARARGS

    @property
    def is_native(self) -> bool:
        return bool(self.access & MethodInfo.ACC_NATIVE)

    @is_native.setter
    def is_native(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_NATIVE
        else:
            self.access &= ~MethodInfo.ACC_NATIVE

    @property
    def is_abstract(self) -> bool:
        return bool(self.access & MethodInfo.ACC_ABSTRACT)

    @is_abstract.setter
    def is_abstract(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_ABSTRACT
        else:
            self.access &= ~MethodInfo.ACC_ABSTRACT

    @property
    def is_strict(self) -> bool:
        return bool(self.access & MethodInfo.ACC_STRICT)

    @is_strict.setter
    def is_strict(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_STRICT
        else:
            self.access &= ~MethodInfo.ACC_STRICT

    @property
    def is_synthetic(self) -> bool:
        return bool(self.access & MethodInfo.ACC_SYNTHETIC)

    @is_synthetic.setter
    def is_synthetic(self, value: bool) -> None:
        if value:
            self.access |= MethodInfo.ACC_SYNTHETIC
        else:
            self.access &= ~MethodInfo.ACC_SYNTHETIC

    def __init__(
            self, access: int, name: ConstInfo, descriptor: ConstInfo,
            attributes: Iterable[AttributeInfo] | None = None,
    ) -> None:
        self.access = access
        self.name = name
        self.descriptor = descriptor
        self.attributes: list[AttributeInfo] = []

        if attributes is not None:
            self.attributes.extend(attributes)

    def __repr__(self) -> str:
        return f"<MethodInfo(access=0x{self.access:04x}, name={self.name!s}, descriptor={self.descriptor!s})>"

    def __str__(self) -> str:
        return f"method_info(0x{self.access:04x},{self.name!s}:{self.descriptor!s})"

    def write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        """
        Writes this method to the binary stream.

        Parameters
        ----------
        stream: IO[bytes]
            The binary stream to write to.
        version: Version
            The class file version.
        pool: ConstPool
            The class file constant pool.

        Raises
        ------
        Exception
            If any writing errors occur.
        """

        stream.write(pack_HHHH(self.access, pool.add(self.name), pool.add(self.descriptor), len(self.attributes)))
        for attribute in self.attributes:
            attribute.write(stream, version, pool)

    def unwrap(self) -> Method:
        """
        Unwraps this method info.

        Returns
        -------
        Method
            The unwrapped `Method`.
        """

        if not isinstance(self.name, UTF8Info):
            raise ValueError("name is not a UTF8 constant")
        if not isinstance(self.descriptor, UTF8Info):
            raise ValueError("descriptor is not a UTF8 constant")

        return Method(
            self.name.decode(), *parse_method_descriptor(self.descriptor.decode()),
            is_public=self.is_public,
            is_private=self.is_private,
            is_protected=self.is_protected,
            is_static=self.is_static,
            is_final=self.is_final,
            is_synchronized=self.is_synchronized,
            is_bridge=self.is_bridge,
            is_varargs=self.is_varargs,
            is_native=self.is_native,
            is_abstract=self.is_abstract,
            is_strictfp=self.is_strict,
            is_synthetic=self.is_synthetic,
        )


# ---------------------------------------- Attributes ---------------------------------------- #

class Code(AttributeInfo):
    """
    The Code attribute.

    A variable length attribute containing the bytecode and other data required for
    method execution.

    Attributes
    ----------
    max_stack: int
        The maximum operand stack depth reached at any point during execution.
    max_locals: int
        The size of the local variable array.
    base: int
        The base offset of the bytecode.
    insns: list[Instruction]
        A list of bytecode the decoded instructions.
        It is assumed that the instructions are ordered correctly.
    handlers: list[Code.ExceptionHandler]
        A list of exception handlers ordered by priority.
    attributes: list[AttributeInfo]
        A list of attributes on this code attribute.
    """

    __slots__ = ("max_stack", "max_locals", "base", "insns", "handlers", "attributes")

    tag = b"Code"
    since = JAVA_1_0
    locations = frozenset({AttributeInfo.LOC_METHOD})

    @classmethod
    def _read(cls, stream: IO[bytes], version: Version, pool: "ConstPool") -> tuple["Code", Metadata]:
        meta = Metadata(__name__)
        # Well known undocumented feature of older Java versions (<45.3) regarding sizes, that we need to account for.
        if version < JAVA_1_1:
            meta.info("read.old", "Read old code size.")
            max_stack, max_locals, size = unpack_BBH(stream.read(4))
        else:
            max_stack, max_locals, size = unpack_HHI(stream.read(8))

        # disassembler = Disassembler()
        # disassembler.disassemble_pure_code(stream, class_file, code_length)

        base = stream.tell()
        insns = []

        wrapper = CodeIOWrapper(stream, base)
        while wrapper.tell() < size:
            instruction = Instruction.read(wrapper, pool)
            insns.append(instruction)

        delta = stream.tell() - (base + size)
        if delta:
            meta.error("read.overread", "Code instructions overread by %i byte(s).", delta)
            stream.seek(-delta, SEEK_CUR)

        # TODO: Version checking.

        handler_count, = unpack_H(stream.read(2))
        handlers = []
        for _ in range(handler_count):
            start_pc, end_pc, handler_pc, type_index = unpack_HHHH(stream.read(8))
            handlers.append(cls.ExceptHandler(start_pc, end_pc, handler_pc, pool[type_index] if type_index else None))

        # disassembler.add_exception_table(exception_table)
        # disassembler.disassemble_non_pure_code(stream, class_file)
        # graph = disassembler.make_graph()

        attr_count, = unpack_H(stream.read(2))
        attributes = []
        for _ in range(attr_count):
            attr, child_meta = AttributeInfo.read(stream, version, pool, AttributeInfo.LOC_CODE)
            attributes.append(attr)
            meta.add(child_meta)

        self = cls(max_stack, max_locals, base, insns, handlers, attributes)
        meta.element = self
        return self, meta

    def __init__(
            self, max_stack: int, max_locals: int, base: int,
            insns:           Iterable["Instruction"] | None = None,
            handlers: Iterable["Code.ExceptHandler"] | None = None,
            attributes:      Iterable[AttributeInfo] | None = None,
    ) -> None:
        super().__init__()
        self.max_stack = max_stack
        self.max_locals = max_locals
        self.base = base
        self.insns: list["Instruction"] = []
        self.handlers: list[Code.ExceptHandler] = []
        self.attributes: list[AttributeInfo] = []

        if insns is not None:
            self.insns.extend(insns)
        if handlers is not None:
            self.handlers.extend(handlers)
        if attributes is not None:
            self.attributes.extend(attributes)

    def __repr__(self) -> str:
        insns_str = ", ".join(map(str, self.insns))
        return (
            f"<Code(max_stack={self.max_stack}, max_locals={self.max_locals}, base={self.base}, insns=[{insns_str}], "
            f"handlers={self.handlers!r})>"
        )

    def __str__(self) -> str:
        insns_str = ",".join(map(str, self.insns))
        handlers_str = ",".join(map(str, self.handlers))
        return f"Code({self.max_stack},{self.max_locals},{self.base},[{insns_str}],[{handlers_str}])"

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, Code) and
            self.max_stack == other.max_stack and
            self.max_locals == other.max_locals and
            self.base == other.base and
            self.insns == other.insns and
            self.handlers == other.handlers and
            self.attributes == other.attributes
        )

    def _write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        if version < JAVA_1_1:
            stream.write(bytes((self.max_stack, self.max_locals)))
            start = stream.tell()
            stream.write(pack_H(0))
        else:
            stream.write(pack_HH(self.max_stack, self.max_locals))
            start = stream.tell()
            stream.write(pack_I(0))

        base = stream.tell()
        wrapper = CodeIOWrapper(stream, base)

        for instruction in self.insns:
            # print(instruction.offset + base, instruction)
            instruction.write(wrapper, pool)

        size = wrapper.tell()
        end = stream.tell()
        stream.seek(start, SEEK_SET)
        if version < JAVA_1_1:
            stream.write(pack_H(size))
        else:
            stream.write(pack_I(size))
        stream.seek(end, SEEK_SET)

        stream.write(pack_H(len(self.handlers)))
        for handler in self.handlers:
            stream.write(pack_HHHH(
                handler.start_pc, handler.end_pc, handler.handler_pc,
                pool.add(handler.class_) if handler.class_ is not None else 0,
            ))
        stream.write(pack_H(len(self.attributes)))
        for attribute in self.attributes:
            attribute.write(stream, version, pool)

    class ExceptHandler:
        """
        An exception handler entry.

        Attributes
        ----------
        start_pc: int
            The starting bytecode offset of this handler's active range.
        end_pc: int
            The ending bytecode offset of this handler's active range.
        handler_pc: int
            The handler bytecode offset.
        class_: ConstInfo | None
            A class constant, used as the type of exception to catch.
            If `None`, all exceptions are caught.
        """

        __slots__ = ("start_pc", "end_pc", "handler_pc", "class_")

        def __init__(self, start_pc: int, end_pc: int, handler_pc: int, class_: ConstInfo | None) -> None:
            self.start_pc = start_pc
            self.end_pc = end_pc
            self.handler_pc = handler_pc
            self.class_ = class_

        def __repr__(self) -> str:
            return (
                f"<Code.ExceptHandler(start_pc={self.start_pc}, end_pc={self.end_pc}, handler_pc={self.handler_pc}, "
                f"class_={self.class_!s})>"
            )

        def __str__(self) -> str:
            return f"handler({self.start_pc}-{self.end_pc}:{self.handler_pc},{self.class_!s})"

        def __eq__(self, other: object) -> bool:
            return (
                isinstance(other, Code.ExceptHandler) and
                self.start_pc == other.start_pc and
                self.end_pc == other.end_pc and
                self.handler_pc == other.handler_pc and
                self.class_ == other.class_
            )


class StackMapTable(AttributeInfo):
    """
    The StackMapTable attribute.

    A variable length attribute containing stack map frames used during verification.

    Attributes
    ----------
    frames: list[StackMapFrame]
        A list of stack map frames, see `StackMapFrame`.
    """

    __slots__ = ("frames",)

    tag = b"StackMapTable"
    since = JAVA_6
    locations = frozenset({AttributeInfo.LOC_CODE})

    @classmethod
    def _read(cls, stream: IO[bytes], version: Version, pool: "ConstPool") -> tuple["StackMapTable", None]:
        count, = unpack_H(stream.read(2))
        frames = []
        for _ in range(count):
            frames.append(StackMapFrame.read(stream, pool))
        return cls(frames), None

    def __init__(self, frames: Iterable[StackMapFrame] | None = None) -> None:
        super().__init__()
        self.frames: list[StackMapFrame] = []
        if frames is not None:
            self.frames.extend(frames)

    def __repr__(self) -> str:
        return f"<StackMapTable(frames={self.frames!r})>"

    def __str__(self) -> str:
        frames_str = ",".join(map(str, self.frames))
        return f"StackMapTable([{frames_str}])"

    def __eq__(self, other: object) -> bool:
        return isinstance(other, StackMapTable) and self.frames == other.frames

    def __getitem__(self, index: int) -> StackMapFrame:
        return self.frames[index]

    def __setitem__(self, index: int, value: StackMapFrame) -> None:
        self.frames[index] = value

    def __delitem__(self, key: int | StackMapFrame) -> None:
        if isinstance(key, int):
            del self.frames[key]
        else:
            self.frames.remove(key)

    def __len__(self) -> int:
        return len(self.frames)

    def _write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        stream.write(pack_H(len(self.frames)))
        for frame in self.frames:
            frame.write(stream, pool)


class Exceptions(AttributeInfo):
    """
    The Exceptions attribute.

    A variable length attribute used to store checked exception information.

    Attributes
    ----------
    exceptions: list[ConstInfo]
        A list of class constants, used to represent checked exceptions that may be
        thrown by this method.
    """

    __slots__ = ("exceptions",)

    tag = b"Exceptions"
    since = JAVA_1_1
    locations = frozenset({AttributeInfo.LOC_METHOD})

    @classmethod
    def _read(cls, stream: IO[bytes], version: Version, pool: "ConstPool") -> tuple["Exceptions", None]:
        count, = unpack_H(stream.read(2))
        return cls([pool[index] for index, in iter_unpack_H(stream.read(count * 2))]), None

    def __init__(self, exceptions: Iterable[ConstInfo] | None = None) -> None:
        super().__init__()
        self.exceptions: list[ConstInfo] = []
        if exceptions is not None:
            self.exceptions.extend(exceptions)

    def __repr__(self) -> str:
        exceptions_str = ", ".join(map(str, self.exceptions))
        return f"<Exceptions(exceptions=[{exceptions_str}])>"

    def __str__(self) -> str:
        exceptions_str = ",".join(map(str, self.exceptions))
        return f"Exceptions([{exceptions_str}])"

    def __eq__(self, other: object) -> bool:
        return isinstance(other, Exceptions) and self.exceptions == other.exceptions

    def __getitem__(self, index: int) -> ConstInfo:
        return self.exceptions[index]

    def __setitem__(self, index: int, value: ConstInfo) -> None:
        self.exceptions[index] = value

    def __delitem__(self, key: int | ConstInfo) -> None:
        if isinstance(key, int):
            del self.exceptions[key]
        else:
            self.exceptions.remove(key)

    def __len__(self) -> int:
        return len(self.exceptions)

    def write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        stream.write(pack_HIH(
            pool.add(self.name or UTF8Info(self.tag)),
            2 + len(self.extra) + len(self.exceptions) * 2,
            len(self.exceptions),
        ))
        for exception in self.exceptions:
            stream.write(pack_H(pool.add(exception)))
        stream.write(self.extra)


class LineNumberTable(AttributeInfo):
    """
    The LineNumberTable attribute.

    A variable length attribute used to store a mapping of bytecode offsets to
    source code line numbers.

    Attributes
    ----------
    lines: list[LineNumberTable.LineNumber]
        A list of line number entries.
    """

    __slots__ = ("lines",)

    tag = b"LineNumberTable"
    since = JAVA_1_0
    locations = frozenset({AttributeInfo.LOC_CODE})

    @classmethod
    def _read(cls, stream: IO[bytes], version: Version, pool: "ConstPool") -> tuple["LineNumberTable", None]:
        count, = unpack_H(stream.read(2))
        lines = []
        for _ in range(count):
            start_pc, line_number = unpack_HH(stream.read(4))
            lines.append(cls.LineNumber(start_pc, line_number))
        return cls(lines), None

    def __init__(self, lines: Iterable["LineNumberTable.LineNumber"] | None = None) -> None:
        super().__init__()
        self.lines: list[LineNumberTable.LineNumber] = []
        if lines is not None:
            self.lines.extend(lines)

    def __repr__(self) -> str:
        return f"<LineNumberTable(lines={self.lines!r})>"

    def __str__(self) -> str:
        lines_str = ",".join(map(str, self.lines))
        return f"LineNumberTable([{lines_str}])"

    def __eq__(self, other: object) -> bool:
        return isinstance(other, LineNumberTable) and self.lines == other.lines

    def __getitem__(self, index: int) -> "LineNumberTable.LineNumber":
        return self.lines[index]

    def __setitem__(self, index: int, value: "LineNumberTable.LineNumber") -> None:
        self.lines[index] = value

    def __delitem__(self, key: Union[int, "LineNumberTable.LineNumber"]) -> None:
        if isinstance(key, int):
            del self.lines[key]
        else:
            self.lines.remove(key)

    def __len__(self) -> int:
        return len(self.lines)

    def write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        stream.write(pack_HIH(
            pool.add(self.name or UTF8Info(self.tag)), 2 + len(self.extra) + len(self.lines) * 4, len(self.lines),
        ))
        for line in self.lines:
            stream.write(pack_HH(line.start_pc, line.line))
        stream.write(self.extra)

    class LineNumber:
        """
        A line number entry.

        Attributes
        ----------
        start_pc: int
            A bytecode offset indicating where the line number starts.
        line: int
            The source code line number.
        """

        __slots__ = ("start_pc", "line")

        def __init__(self, start_pc: int, line: int) -> None:
            self.start_pc = start_pc
            self.line = line

        def __repr__(self) -> str:
            return f"<LineNumberTable.LineNumber(start_pc={self.start_pc}, line={self.line})>"

        def __str__(self) -> str:
            return f"line_number({self.start_pc}:{self.line})"

        def __eq__(self, other: object) -> bool:
            return (
                isinstance(other, LineNumberTable.LineNumber) and
                self.start_pc == other.start_pc and
                self.line == other.line
            )


class LocalVariableTable(AttributeInfo):
    """
    The LocalVariableTable attribute.

    A variable length attribute used to store local variable information.

    Attributes
    ----------
    locals: list[LocalVariableTable.LocalVariable]
        A list of local variable information entries.
    """

    __slots__ = ("locals",)

    tag = b"LocalVariableTable"
    # Although maybe true, it was most likely called LocalVariables. Unfortunately the 1.0.2 compiler doesn't emit it,
    # so we can't be sure.
    since = JAVA_1_0
    locations = frozenset({AttributeInfo.LOC_CODE})

    @classmethod
    def _read(cls, stream: IO[bytes], version: Version, pool: "ConstPool") -> tuple["LocalVariableTable", None]:
        count, = unpack_H(stream.read(2))
        locals_ = []
        for _ in range(count):
            start_pc, length, name_index, desc_index, index = unpack_HHHHH(stream.read(10))
            locals_.append(cls.LocalVariable(start_pc, length, pool[name_index], pool[desc_index], index))
        return cls(locals_), None

    def __init__(self, locals_: Iterable["LocalVariableTable.LocalVariable"] | None = None) -> None:
        super().__init__()
        self.locals: list[LocalVariableTable.LocalVariable] = []
        if locals_ is not None:
            self.locals.extend(locals_)

    def __repr__(self) -> str:
        return f"<LocalVariableTable(locals={self.locals!r})>"

    def __str__(self) -> str:
        locals_str = ",".join(map(str, self.locals))
        return f"LocalVariableTable([{locals_str}])"

    def __eq__(self, other: object) -> bool:
        return isinstance(other, LocalVariableTable) and self.locals == other.locals

    def __getitem__(self, index: int) -> "LocalVariableTable.LocalVariable":
        return self.locals[index]

    def __setitem__(self, index: int, value: "LocalVariableTable.LocalVariable") -> None:
        self.locals[index] = value

    def __delitem__(self, key: Union[int, "LocalVariableTable.LocalVariable"]) -> None:
        if isinstance(key, int):
            del self.locals[key]
        else:
            self.locals.remove(key)

    def __len__(self) -> int:
        return len(self.locals)

    def write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        stream.write(pack_HIH(
            pool.add(self.name or UTF8Info(self.tag)), 2 + len(self.extra) + len(self.locals) * 10, len(self.locals),
        ))
        for local in self.locals:
            stream.write(pack_HHHHH(
                local.start_pc, local.length, pool.add(local.name), pool.add(local.descriptor), local.index,
            ))
        stream.write(self.extra)

    class LocalVariable:
        """
        A local variable table entry.

        Attributes
        ----------
        start_pc: int
            The bytecode offset at which the current local range starts.
        length: int
            The length of the range.
        name: ConstInfo
            A UTF8 constant, used as the name of the local variable.
        descriptor: ConstInfo
            A UTF8 constant, used as the descriptor detailing the type of the local
            variable.
        index: int
            The index of the local variable in the local variable array.
        """

        __slots__ = ("start_pc", "length", "name", "descriptor", "index")

        def __init__(self, start_pc: int, length: int, name: ConstInfo, descriptor: ConstInfo, index: int) -> None:
            self.start_pc = start_pc
            self.length = length
            self.name = name
            self.descriptor = descriptor
            self.index = index

        def __repr__(self) -> str:
            return (
                f"<LocalVariableTable.LocalVariable(start_pc={self.start_pc}, length={self.length}, name={self.name!s}, "
                f"descriptor={self.descriptor!s}, index={self.index})>"
            )

        def __str__(self) -> str:
            return f"local_variable({self.start_pc}+{self.length},{self.name!s},{self.descriptor!s},{self.index})"

        def __eq__(self, other: object) -> bool:
            return (
                isinstance(other, LocalVariableTable.LocalVariable) and
                self.start_pc == other.start_pc and
                self.length == other.length and
                self.name == other.name and
                self.descriptor == other.descriptor and
                self.index == other.index
            )


class LocalVariableTypeTable(AttributeInfo):
    """
    The LocalVariableTypeTable attribute.

    A variable length attribute used to store local variable information.
    It differs from `LocalVariableTable` in that generic signature information is
    stored.

    Attributes
    ----------
    locals: list[LocalVariableTypeTable.LocalVariable]
        A list of local variable information entries.
    """

    __slots__ = ("locals",)

    tag = b"LocalVariableTypeTable"
    since = JAVA_5
    locations = frozenset({AttributeInfo.LOC_CODE})

    @classmethod
    def _read(cls, stream: IO[bytes], version: Version, pool: "ConstPool") -> tuple["LocalVariableTypeTable", None]:
        count, = unpack_H(stream.read(2))
        locals_ = []
        for _ in range(count):
            start_pc, length, name_index, sig_index, index = unpack_HHHHH(stream.read(10))
            locals_.append(cls.LocalVariable(start_pc, length, pool[name_index], pool[sig_index], index))
        return cls(locals_), None

    def __init__(self, locals_: Iterable["LocalVariableTypeTable.LocalVariable"] | None = None) -> None:
        super().__init__()
        self.locals: list[LocalVariableTypeTable.LocalVariable] = []
        if locals_ is not None:
            self.locals.extend(locals_)

    def __repr__(self) -> str:
        return f"<LocalVariableTypeTable(locals={self.locals!r})>"

    def __str__(self) -> str:
        locals_str = ",".join(map(str, self.locals))
        return f"LocalVariableTypeTable([{locals_str}])"

    def __eq__(self, other: object) -> bool:
        return isinstance(other, LocalVariableTypeTable) and self.locals == other.locals

    def __getitem__(self, index: int) -> "LocalVariableTypeTable.LocalVariable":
        return self.locals[index]

    def __setitem__(self, index: int, value: "LocalVariableTypeTable.LocalVariable") -> None:
        self.locals[index] = value

    def __delitem__(self, key: Union[int, "LocalVariableTypeTable.LocalVariable"]) -> None:
        if isinstance(key, int):
            del self.locals[key]
        else:
            self.locals.remove(key)

    def __len__(self) -> int:
        return len(self.locals)

    def write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        stream.write(pack_HIH(
            pool.add(self.name or UTF8Info(self.tag)), 2 + len(self.extra) + len(self.locals) * 10, len(self.locals),
        ))
        for local in self.locals:
            stream.write(pack_HHHHH(
                local.start_pc, local.length, pool.add(local.name), pool.add(local.signature), local.index,
            ))
        stream.write(self.extra)

    class LocalVariable:
        """
        A local variable type table entry.

        Attributes
        ----------
        start_pc: int
            The bytecode offset at which the current local range starts.
        length: int
            The length of the range.
        name: ConstInfo
            A UTF8 constant, used as the name of the local variable.
        signature: ConstInfo
            A UTF8 constant, used as the generic signature.
        index: int
            The index of the local variable in the local variable array.
        """

        __slots__ = ("start_pc", "length", "name", "signature", "index")

        def __init__(self, start_pc: int, length: int, name: ConstInfo, signature: ConstInfo, index: int) -> None:
            self.start_pc = start_pc
            self.length = length
            self.name = name
            self.signature = signature
            self.index = index

        def __repr__(self) -> str:
            return (
                f"<LocalVariableTypeTable.LocalVariable(start_pc={self.start_pc}, length={self.length}, "
                f"name={self.name!s}, signature={self.signature!s}, index={self.index})>"
            )

        def __str__(self) -> str:
            return f"local_variable({self.start_pc}+{self.length},{self.name!s},{self.signature!s},{self.index})"

        def __eq__(self, other: object) -> bool:
            return (
                isinstance(other, LocalVariableTypeTable.LocalVariable) and
                self.start_pc == other.start_pc and
                self.length == other.length and
                self.name == other.name and
                self.signature == other.signature and
                self.index == other.index
            )


class AnnotationDefault(AttributeInfo):
    """
    An AnnotationDefault attribute primitive.

    A variable length attribute used to store the default value of an element in an
    annotation interface.

    Attributes
    ----------
    default: ElementValue
        The default value of the annotation interface element.
    """

    __slots__ = ("default",)

    tag = b"AnnotationDefault"
    since = JAVA_5
    locations = frozenset({AttributeInfo.LOC_METHOD})

    @classmethod
    def _read(cls, stream: IO[bytes], version: Version, pool: "ConstPool") -> tuple["AnnotationDefault", None]:
        return cls(ElementValue.read(stream, pool)), None

    def __init__(self, default: ElementValue) -> None:
        super().__init__()
        self.default = default

    def __repr__(self) -> str:
        return f"<AnnotationDefault(default={self.default!r})>"

    def __str__(self) -> str:
        return f"AnnotationDefault({self.default!s})"

    def __eq__(self, other: object) -> bool:
        return isinstance(other, AnnotationDefault) and self.default == other.default

    def _write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        self.default.write(stream, pool)


class MethodParameters(AttributeInfo):
    """
    The MethodParameters attribute.

    A variable length attribute used to record information about formal method
    parameters.

    Attributes
    ----------
    params: list[MethodParameters.Parameter]
        A list of formal parameters.
    """

    __slots__ = ("params",)

    tag = b"MethodParameters"
    since = JAVA_8
    locations = frozenset({AttributeInfo.LOC_METHOD})

    @classmethod
    def _read(cls, stream: IO[bytes], version: Version, pool: "ConstPool") -> tuple["MethodParameters", None]:
        count, = stream.read(1)
        params = []
        for _ in range(count):
            name_index, flags = unpack_HH(stream.read(4))
            params.append(cls.Parameter(pool[name_index] if name_index else None, flags))
        return cls(params), None

    def __init__(self, params: Iterable["MethodParameters.Parameter"] | None = None) -> None:
        super().__init__()
        self.params: list[MethodParameters.Parameter] = []
        if params is not None:
            self.params.extend(params)

    def __repr__(self) -> str:
        return f"<MethodParameters(params={self.params!r})>"

    def __str__(self) -> str:
        params_str = ",".join(map(str, self.params))
        return f"MethodParameters([{params_str}])"

    def __eq__(self, other: object) -> bool:
        return isinstance(other, MethodParameters) and self.params == other.params

    def __getitem__(self, index: int) -> "MethodParameters.Parameter":
        return self.params[index]

    def __setitem__(self, index: int, value: "MethodParameters.Parameter") -> None:
        self.params[index] = value

    def __delitem__(self, key: Union[int, "MethodParameters.Parameter"]) -> None:
        if isinstance(key, int):
            del self.params[key]
        else:
            self.params.remove(key)

    def __len__(self) -> int:
        return len(self.params)

    def write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        stream.write(pack_HI(pool.add(UTF8Info(self.tag)), 1 + len(self.extra) + len(self.params) * 4))
        stream.write(bytes((len(self.params),)))
        for param in self.params:
            stream.write(pack_HH(pool.add(param.name) if param.name is not None else 0, param.flags))
        stream.write(self.extra)

    class Parameter:
        """
        A formal parameter entry.

        Attributes
        ----------
        ACC_FINAL: int
            Access flag denoting that this formal parameter is declared `final` in the
            source.
        ACC_SYNTHETIC: int
            Access flag denoting that this formal parameter is not present in the source.
        ACC_MANDATED: int
            Access flag denoting that this formal parameter was implicitly declared in
            the source.

        name: ConstInfo | None
            A UTF8 constant, used as the name of this formal parameter.
            If `None`, then the formal parameter has no name.
        flags: int
            A bitmask indicating the properties of this formal parameter.
        """

        __slots__ = ("name", "flags")

        ACC_FINAL     = 0x0010
        ACC_SYNTHETIC = 0x1000
        ACC_MANDATED  = 0x8000

        @property
        def is_final(self) -> bool:
            return bool(self.flags & MethodParameters.Parameter.ACC_FINAL)

        @is_final.setter
        def is_final(self, value: bool) -> None:
            if value:
                self.flags |= MethodParameters.Parameter.ACC_FINAL
            else:
                self.flags &= ~MethodParameters.Parameter.ACC_FINAL

        @property
        def is_synthetic(self) -> bool:
            return bool(self.flags & MethodParameters.Parameter.ACC_SYNTHETIC)

        @is_synthetic.setter
        def is_synthetic(self, value: bool) -> None:
            if value:
                self.flags |= MethodParameters.Parameter.ACC_SYNTHETIC
            else:
                self.flags &= ~MethodParameters.Parameter.ACC_SYNTHETIC

        @property
        def is_mandated(self) -> bool:
            return bool(self.flags & MethodParameters.Parameter.ACC_MANDATED)

        @is_mandated.setter
        def is_mandated(self, value: bool) -> None:
            if value:
                self.flags |= MethodParameters.Parameter.ACC_MANDATED
            else:
                self.flags &= ~MethodParameters.Parameter.ACC_MANDATED

        def __init__(self, name: ConstInfo | None, flags: int) -> None:
            self.name = name
            self.flags = flags

        def __repr__(self) -> str:
            return f"<MethodParameters.Parameter(name={self.name!s}, flags=0x{self.flags:04x})>"

        def __str__(self) -> str:
            return f"parameter({self.name!s},0x{self.flags:04x})"

        def __eq__(self, other: object) -> bool:
            return (
                isinstance(other, MethodParameters.Parameter) and self.name == other.name and self.flags == other.flags
            )


class RuntimeVisibleParameterAnnotations(AttributeInfo):
    """
    A RuntimeVisibleParameterAnnotations attribute primitive.

    This is a variable length attribute found in methods, storing runtime visible
    annotations declared on the formal parameters of this method.

    Attributes
    ----------
    annotations: list[ParameterAnnotations]
        A list of runtime visible annotations declared on each formal parameter of
        this method.
    """

    __slots__ = ("annotations",)

    tag = b"RuntimeVisibleParameterAnnotations"
    since = JAVA_5
    locations = frozenset({AttributeInfo.LOC_METHOD})

    @classmethod
    def _read(
            cls, stream: IO[bytes], version: Version, pool: "ConstPool",
    ) -> tuple["RuntimeVisibleParameterAnnotations", None]:
        count, = stream.read(1)
        annotations = []
        for _ in range(count):
            annotations.append(ParameterAnnotations.read(stream, pool))
        return cls(annotations), None

    def __init__(self, annotations: Iterable[ParameterAnnotations] | None = None) -> None:
        super().__init__()
        self.annotations: list[ParameterAnnotations] = []
        if annotations is not None:
            self.annotations.extend(annotations)

    def __repr__(self) -> str:
        return f"<RuntimeVisibleParameterAnnotations(annotations={self.annotations!r})>"

    def __str__(self) -> str:
        annotations_str = ",".join(map(str, self.annotations))
        return f"RuntimeVisibleParametersAnnotations([{annotations_str}])"

    def __eq__(self, other: object) -> bool:
        return isinstance(other, RuntimeVisibleParameterAnnotations) and self.annotations == other.annotations

    def __getitem__(self, index: int) -> ParameterAnnotations:
        return self.annotations[index]

    def __setitem__(self, index: int, value: ParameterAnnotations) -> None:
        self.annotations[index] = value

    def __delitem__(self, key: int | ParameterAnnotations) -> None:
        if isinstance(key, int):
            del self.annotations[key]
        else:
            self.annotations.remove(key)

    def __len__(self) -> int:
        return len(self.annotations)

    def _write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        stream.write(bytes((len(self.annotations),)))
        for annotation in self.annotations:
            annotation.write(stream, pool)


class RuntimeInvisibleParameterAnnotations(AttributeInfo):
    """
    A RuntimeInvisibleParameterAnnotations attribute primitive.

    A variable length attribute used to store runtime-invisible annotations declared
    on the formal parameters of the method containing this attribute.

    Attributes
    ----------
    annotations: list[ParameterAnnotations]
        A list of runtime invisible annotations declared on each formal parameter of
        this method.
    """

    __slots__ = ("annotations",)

    tag = b"RuntimeInvisibleParameterAnnotations"
    since = JAVA_5
    locations = frozenset({AttributeInfo.LOC_METHOD})

    @classmethod
    def _read(
            cls, stream: IO[bytes], version: Version, pool: "ConstPool",
    ) -> tuple["RuntimeInvisibleParameterAnnotations", None]:
        count, = stream.read(1)
        annotations = []
        for _ in range(count):
            annotations.append(ParameterAnnotations.read(stream, pool))
        return cls(annotations), None

    def __init__(self, annotations: Iterable[ParameterAnnotations] | None = None) -> None:
        super().__init__()
        self.annotations: list[ParameterAnnotations] = []
        if annotations is not None:
            self.annotations.extend(annotations)

    def __repr__(self) -> str:
        return f"<RuntimeInvisibleParameterAnnotations(annotations={self.annotations!r})>"

    def __str__(self) -> str:
        annotations_str = ",".join(map(str, self.annotations))
        return f"RuntimeInvisibleParametersAnnotations([{annotations_str}])"

    def __eq__(self, other: object) -> bool:
        return isinstance(other, RuntimeInvisibleParameterAnnotations) and self.annotations == other.annotations

    def __getitem__(self, index: int) -> ParameterAnnotations:
        return self.annotations[index]

    def __setitem__(self, index: int, value: ParameterAnnotations) -> None:
        self.annotations[index] = value

    def __delitem__(self, key: int | ParameterAnnotations) -> None:
        if isinstance(key, int):
            del self.annotations[key]
        else:
            self.annotations.remove(key)

    def __len__(self) -> int:
        return len(self.annotations)

    def _write(self, stream: IO[bytes], version: Version, pool: "ConstPool") -> None:
        stream.write(bytes((len(self.annotations),)))
        for annotation in self.annotations:
            annotation.write(stream, pool)
